// SiliconPaginator_CommonFunctions.jsxvar SiliconPaginator_CommonFunctions_versionStr = "1.2";function consoleout(str) {	if (app.name == "Adobe InDesign Server")		app.consoleout(str);	else		$.writeln(str);}var logFile;var bSeenErrorMsgType;var gb_includeLogTimestamps = true;var gb_flushLogFile = true;var gb_idsConsoleoutLogMsgs = false;function setupLogFile(logFilePath, bIncludeTimestamps) {	if (typeof bIncludeTimestamps !== "undefined")		gb_includeLogTimestamps = bIncludeTimestamps;	logFile = new File(logFilePath);	if (logFile.exists)		logFile.remove();	logFile.open('w');	bSeenErrorMsgType = false;}function logMessage(str, msgType) {	if (typeof msgType === "undefined")		var msgType = "Info";	if (typeof logFile !== "undefined") {		if (gb_includeLogTimestamps)			str = getTime() + "|" + str;		str = msgType + "|" + str;		if (gb_idsConsoleoutLogMsgs)			consoleout(str);		logFile.writeln(str);		if (gb_flushLogFile)			flushLogFile();		if (msgType == "Error")			bSeenErrorMsgType = true;	}}function flushLogFile(){	try	{		logFile.close();		logFile.open('a');	} catch(e)	{}}function closeLogFile() {	if (typeof logFile !== "undefined")		logFile.close();}function ensureEndsWithSeparator(name) {	if(name.charAt(name.length - 1) != '/') {		name += '/';	}	return name;}function pad4(value, length) {	if(value.length < length) {		value = ('0000' + value).slice(-length);	}	return value;}/*** Creates the timestamp string.* @return date & time* @type string*/function getTime() {    var date = new Date();    var time = pad4(date.getFullYear(), 4) + "/" + pad4( date.getMonth() + 1, 2) + "/" + pad4(date.getDate(), 2) + " " +		pad4(date.getHours(), 2) + ":" + pad4(date.getMinutes(), 2) + ":" + pad4(date.getSeconds(), 2) +"."+ pad4(date.getMilliseconds(), 3);    return time;};function processJob(graphicFolderBasePath, inDesignFilePath, overviewData, textframeData, storyData, staticData, dynamicData, outputPathSansExt, xmlStoryData, xmlVariableData, conditionsData) {	var retVal = "FAILURE";	logMessage("Beginning job with SiliconPublishing_CommonFunctions script version " + SiliconPaginator_CommonFunctions_versionStr);	logMessage("InDesign file: " + inDesignFilePath);	logMessage("Graphic folder base path: " + graphicFolderBasePath);	if (typeof xmlStoryData === "undefined")		var xmlStoryData = [];	if (typeof xmlVariableData === "undefined")		var xmlVariableData = [];	graphicFolderBasePath = normalizePath(graphicFolderBasePath, false);	for (var i=0; i<overviewData.length; i++) {		overviewData[i] = normalizePath(overviewData[i]);	}	for (i=0; i<storyData.length; i++) {		storyData[i][0] = normalizePath(storyData[i][0]);		storyData[i][1] = normalizePath(storyData[i][1]);	}	for (i=0; i<staticData.length; i++) {		staticData[i][0] = normalizePath(staticData[i][0]);		staticData[i][1] = normalizePath(staticData[i][1]);	}//~ 	for (var i=0; i<singleRowData.length; i++) {//~ 		singleRowData[i][0] = normalizePath(singleRowData[i][0]);//~ 		singleRowData[i][1] = normalizePath(singleRowData[i][1]);//~ 	}//~ 	for (i=0; i<multiRowData.length; i++) {//~ 		multiRowData[i][0] = normalizePath(multiRowData[i][0]);//~ 		multiRowData[i][1] = normalizePath(multiRowData[i][1]);//~ 	}	for (i=0; i<dynamicData.length; i++) {		dynamicData[i][0] = normalizePath(dynamicData[i][0]);		dynamicData[i][1] = normalizePath(dynamicData[i][1]);	}	for (i=0; i<xmlStoryData.length; i++) {		xmlStoryData[i][0] = normalizePath(xmlStoryData[i][0]);		xmlStoryData[i][2] = normalizePath(xmlStoryData[i][2]);		xmlStoryData[i][3] = normalizePath(xmlStoryData[i][3]);	}	for (i=0; i<xmlVariableData.length; i++) {		xmlVariableData[i][0] = normalizePath(xmlVariableData[i][0]);		xmlVariableData[i][1] = normalizePath(xmlVariableData[i][1]);	}	retVal = populateTemplate(graphicFolderBasePath, inDesignFilePath, overviewData, textframeData, storyData, staticData, dynamicData, outputPathSansExt, xmlStoryData, xmlVariableData, conditionsData);	logMessage("Completion status: " + retVal);	return retVal;}function populateTemplate(graphicFolderBasePath, inDesignFilePath, overviewData, textframeData, storyData, staticData, dynamicData, outputPathSansExt, xmlStoryData, xmlVariableData, conditionsData){	if (typeof xmlStoryData === "undefined")		var xmlStoryData = [];	if (typeof xmlVariableData === "undefined")		var xmlVariableData = [];	if (typeof conditionsData === "undefined")		var conditionsData = [];	var retVal = "FAILURE";	if (File(inDesignFilePath).exists) {		inhibitUI();		var inDesignFile = File(inDesignFilePath);		var document = app.open(inDesignFile);		var bDeleteTemp = false;		if (!document.saved) {			// came from idml or indt -- save to indd			var pathSansExt = inDesignFilePath.substr(0,inDesignFilePath.lastIndexOf("."));			var tempPath = pathSansExt + "_temp.indd";			var tempFile = new File(tempPath);			document.save(tempFile);			bDeleteTemp = true;		}		// OVERVIEW DATA (early shot at variables -- also done at end)		logMessage("Processing " + overviewData.length + " variable lists");		for (var i=0; i<overviewData.length; i++) {			var overviewDataPath = overviewData[i];			processOverviewData(document, overviewDataPath, graphicFolderBasePath);		}		// TEXTFRAMES (do first to allow variable insertion into frames)		logMessage("Processing " + textframeData.length + " textframes");		for (var i=0; i<textframeData.length; i++) {			var dataFilePath =  textframeData[i][0];			var searchStr = textframeData[i][1];			if(searchStr.length > 0){				logMessage("searchStr '" + searchStr + "'");				if (dataFilePath.length > 0) {					logMessage("dataFilePath: " + dataFilePath);					if (File(dataFilePath).exists) {						logMessage("Found data file; processing");						processTextFrameJob(document, dataFilePath, searchStr);					}				} else {					logMessage("Data file not found; removing text frame", "Warning");					removeTextFrame(document, searchStr, true);				}			} else if (searchStr.length > 0) {				logMessage("No search string provided; ignoring dataFilePath: " + datafilePath, "Error");			}		}		// STORIES		logMessage("Processing " + storyData.length + " stories");		for (var i=0; i<storyData.length; i++) {			var dataFilePath =  storyData[i][0];			var xmlFilePath =  storyData[i][1];			var searchStr = storyData[i][2];			logMessage("Story " + i);			logMessage("searchStr '" + searchStr + "'");			logMessage("dataFilePath: " + dataFilePath);			logMessage("xmlFilePath (snippet): " + xmlFilePath);			if (/* dataFilePath.length > 0 && */ xmlFilePath.length > 0) {				if(searchStr.length > 0 && /*(File(dataFilePath).exists)&&*/(File(xmlFilePath).exists)){					var data = "";					if (dataFilePath.length > 0) {						if (File(dataFilePath).exists) {							logMessage("Data file found");							data = readTextFile(dataFilePath);						} else {							logMessage("Data file not found; skipping this story", "Error");							continue;						}					} else {						logMessage("No data file provided (not an error if story has no variables)");					}					var xml = readXMLFile(xmlFilePath);					logMessage("Parameters OK; processing story");					processStoryJob(document, data, xml, graphicFolderBasePath, searchStr);				} else {					logMessage("No search string provided; ignoring dataFilePath: " + datafilePath, "Error");				}			} else if (searchStr.length > 0) {				logMessage("No snippet path provided; removing searchStr from template", "Error");				removeSearchStringInstance(document, searchStr, true);			}		}		// STATIC TABLES		logMessage("Processing " + staticData.length + " static tables");		for (var i=0; i<staticData.length; i++) {			var dataFilePath =  staticData[i][0];			var xmlFilePath =  staticData[i][1];			var searchStr = staticData[i][2];			logMessage("Static table " + i);			logMessage("searchStr '" + searchStr + "'");			logMessage("dataFilePath: " + dataFilePath);			logMessage("xmlFilePath (snippet): " + xmlFilePath);			if (xmlFilePath.length > 0) {				if(searchStr.length > 0) {					if (File(xmlFilePath).exists) {						var data = "";						if (dataFilePath.length > 0) {							if (File(dataFilePath).exists)								data = readTextFile(dataFilePath);							else  {								logMessage("Data file not found; skipping this story", "Error");								continue;							}						} else {							logMessage("No data file provided (not an error if story has no variables)");						}						var xml = readXMLFile(xmlFilePath);						logMessage("Parameters OK; processing table");						processStaticJob(document, data, xml, graphicFolderBasePath, searchStr);					} else {						logMessage("Snippet file not found; skipping this table", "Error");					}				} else {					logMessage("No search string provided; skipping this table", "Error");				}			} else if (searchStr.length > 0) {				logMessage("No snippet path provided; removing searchStr from template", "Error");				removeSearchStringInstance(document, searchStr, true);			}		}		// DYNAMIC TABLES		logMessage("Processing " + dynamicData.length + " dynamic tables");		for (var i=0; i<dynamicData.length; i++) {			var dataFilePath =  dynamicData[i][0];			var xmlFilePath =  dynamicData[i][1];			var searchStr = dynamicData[i][2];			logMessage("Table " + i);			logMessage("searchStr '" + searchStr + "'");			logMessage("dataFilePath: " + dataFilePath);			logMessage("xmlFilePath (snippet): " + xmlFilePath);			if (dataFilePath.length > 0 && xmlFilePath.length > 0) {				if(searchStr.length > 0 && (File(dataFilePath).exists)&&(File(xmlFilePath).exists)){					var data = readTextFile(dataFilePath);					var xml = readXMLFile(xmlFilePath);					logMessage("Parameters OK; processing table");					processDynamicJob(document, data, xml, graphicFolderBasePath, searchStr);				} else {					if (searchStr.length == 0)						logMessage("Search string not provided", "Error");					if (!File(dataFilePath).exists)						logMessage("Data file not found", "Error");					if (!File(xmlFilePath).exists)						logMessage("Snippet file not found", "Error");					logMessage("Skipping this table", "Error");				}			} else if (searchStr.length > 0) {				if (dataFilePath.length == 0)					logMessage("Data file path not provided", "Error");				if (xmlFilePath.length == 0)					logMessage("Snippet file path not provided", "Error");				logMessage("Removing searchStr from template", "Error");				removeSearchStringInstance(document, searchStr, true);			}		}		// XML STORIES		logMessage("Processing " + xmlStoryData.length + " xml stories");		for (var i=0; i<xmlStoryData.length; i++) {			var dataFilePath =  xmlStoryData[i][0];			var elementName = xmlStoryData[i][1];			var mapFilePath = xmlStoryData[i][2];			var xmlFilePath =  xmlStoryData[i][3];			var searchStr = xmlStoryData[i][4];			logMessage("Story " + i);			logMessage("searchStr '" + searchStr + "'");			logMessage("dataFilePath: " + dataFilePath);			logMessage("elementName:" + elementName);			logMessage("mapFilePath: " + mapFilePath);			logMessage("xmlFilePath (snippet): " + xmlFilePath);			if (/* dataFilePath.length > 0 && */ xmlFilePath.length > 0) {				if(searchStr.length > 0 && /*(File(dataFilePath).exists)&&*/(File(xmlFilePath).exists)){					var data = "";					var map = "";					if (dataFilePath.length > 0) {						if (File(dataFilePath).exists) {//							logMessage("Data file found");							data = readXMLFile(dataFilePath);						} else {							logMessage("Data file not found; skipping this story", "Error");							continue;						}					} else {						logMessage("No data file provided (not an error if story has no variables)");					}					if (mapFilePath.length > 0) {						if (File(mapFilePath).exists) {//							logMessage("Map file found");							map = readTextFile(mapFilePath);						} else {							logMessage("Map file not found; skipping this xml story", "Error");							continue;						}					} else {						logMessage("No map file provided (not an error if xml story has no variables)");					}//					logMessage("Snippet file found");					var xml = readXMLFile(xmlFilePath);//					logMessage("Parameters OK; processing xml story");					processXMLStoryJob(document, data, elementName, map, xml, graphicFolderBasePath, searchStr);//					processXMLStoryJobIncremental(document, data, elementName, map, xml, graphicFolderBasePath, searchStr);				} else {					logMessage("No search string provided; ignoring dataFilePath: " + datafilePath, "Error");				}			} else if (searchStr.length > 0) {				logMessage("No snippet path provided; removing searchStr from template", "Warning");				removeSearchStringInstance(document, searchStr, true);			}		}		// DO THIS AGAIN IN CASE ANY TABLE INSERTION RESULTED IN NEW STORIES		// STORIES		logMessage("Processing " + storyData.length + " stories");		for (var i=0; i<storyData.length; i++) {			var dataFilePath =  storyData[i][0];			var xmlFilePath =  storyData[i][1];			var searchStr = storyData[i][2];			logMessage("Story " + i);			logMessage("searchStr '" + searchStr + "'");			logMessage("dataFilePath: " + dataFilePath);			logMessage("xmlFilePath (snippet): " + xmlFilePath);			if (/* dataFilePath.length > 0 && */ xmlFilePath.length > 0) {				if(searchStr.length > 0 && /*(File(dataFilePath).exists)&&*/(File(xmlFilePath).exists)){					var data = "";					if (dataFilePath.length > 0) {						if (File(dataFilePath).exists) {							logMessage("Data file found");							data = readTextFile(dataFilePath);						} else {							logMessage("Data file not found; skipping this story", "Error");							continue;						}					} else {						logMessage("No data file provided (not an error if story has no variables)");					}					var xml = readXMLFile(xmlFilePath);					logMessage("Parameters OK; processing story");					processStoryJob(document, data, xml, graphicFolderBasePath, searchStr);				} else {					logMessage("No search string provided; ignoring dataFilePath: " + datafilePath, "Error");				}			} else if (searchStr.length > 0) {				logMessage("No snippet path provided; removing searchStr from template", "Error");				removeSearchStringInstance(document, searchStr, true);			}		}		// OVERVIEW DATA (do last in case some variables are also in table headers)		logMessage("Processing " + overviewData.length + " variable lists");		for (var i=0; i<overviewData.length; i++) {			var overviewDataPath = overviewData[i];			processOverviewData(document, overviewDataPath, graphicFolderBasePath);		}		// XML Variable DATA (do last in case some variables are also in table headers)		logMessage("Processing " + xmlVariableData.length + " xml variable lists");		for (var i=0; i<xmlVariableData.length; i++) {			var dataFilePath = xmlVariableData[i][0];			var mapFilePath = xmlVariableData[i][1];			processXMLVariableList(document, dataFilePath, mapFilePath);		}		// Conditional variable stuff here		cleanupConditionalVariables(document);		fixClippingPaths(document);		document = app.documents[0].getElements()[0];	// refresh the reference		// if conditions are stated, try to set them		for (i=0; i<conditionsData.length; i++) {			try {				var thisCond = document.conditions.itemByName(conditionsData[i][0]);				thisCond.visible = conditionsData[i][1] == "true";			} catch (e) {}	// no worries if not found		}		// Save		var reportFile = new File(outputPathSansExt + ".indd");		var idmlFile = new File(outputPathSansExt + ".idml");		var pdfFile = new File(outputPathSansExt + ".pdf");		logMessage("Saving document to: " + reportFile.fsName);		document.save(reportFile);		if (bDeleteTemp)			tempFile.remove();		logMessage("Exporting idml to: " + idmlFile.fsName);		document.exportFile( ExportFormat.INDESIGN_MARKUP, idmlFile );		var myPresets = app.pdfExportPresets.everyItem().name;        logMessage("MY PRESETS: " + myPresets);		// Make pdf		logMessage("Exporting pdf to: " + pdfFile.fsName);		var initialPDFExportPrefs = app.pdfExportPreferences.properties;		app.pdfExportPreferences.pageRange = PageRange.ALL_PAGES;		app.pdfExportPreferences.includeHyperlinks = true;		if (is_server_execution())			document.exportFile( ExportFormat.PDF_TYPE, pdfFile, "[High Quality Print]");		else			document.exportFile(  ExportFormat.PDF_TYPE, pdfFile, false, "[High Quality Print]");		app.pdfExportPreferences.properties = initialPDFExportPrefs;		// close and restore UI		document.close();		restoreUI();		retVal = bSeenErrorMsgType ? "FAILURE" : ("SUCCESS|" + pdfFile.fsName);	}	return retVal;}/////////////////////////////////  OVERVIEW DATA  /////////////////////////////////////////////////// very simple S1-like scheme, though data file lacks "{{" and "}}"// each line is a key and a value -- the indd file has the "{{" and "}}" around key placeholdersfunction processOverviewData(document, overviewDataPath, graphicFolderBasePath) {	try {		var data = readTextFile(overviewDataPath);		data = splitData(data);		// data should be an array		for (var i=0; i<data.length; i++) {			var thisLine = data[i];			if (thisLine.length < 2)				continue;			var key = thisLine[0];			if (key.length == 0)				continue;			var value = thisLine[1];			if (key.toLowerCase() == "key")				continue;	// skip header if present			if (key.substr(0,1) != "@") {	// normal find/change				resetFindChangePreferences();				var saved = app.findChangeTextOptions.includeMasterPages;				app.findChangeTextOptions.includeMasterPages = true;				value = processSpecialCharacters(value);				////~ 				// original simple approach that does not support conditionals//~ 				app.findTextPreferences.findWhat = "{{" + key + "}}";//~ 				app.changeTextPreferences.changeTo = value;//~ 				var results = document.findText();//~ 				document.changeText();				var foundItems;				var variableName = key;				var content = value;				//From PrestoboxLayout.jsx				//Does the variable exist in a conditional variable?				app.findGrepPreferences.findWhat = "\\[\\[([^\\{]*)\\{\\{" + variableName + "\\}\\}([^\\]]*)\\]\\]";				foundItems = document.findGrep(true);				//If foundItems contains text objects, then the variable existed				//inside conditional markup.				if(foundItems.length > 0){					app.findTextPreferences.findWhat = "{{" + variableName + "}}";					app.changeTextPreferences.changeTo = content;					//If the variable is empty, simply remove it.					if(content == ""){						for(textCounter = 0; textCounter < foundItems.length; textCounter++){							foundItems[textCounter].remove();						}					}					else{						//The variable wasn't empty, so replace the variable and then						//remove the conditional text markers.						for(textCounter = 0; textCounter < foundItems.length; textCounter++){							//Change the variable in the found text. Note that we do it this way							//because using grep and the captured text ($1, $2) from the above							//findGrep results in misplaced formatting when the found text							//contains more than one format.							foundItems[textCounter].changeText();							//Remove conditional markers from the found text.							//app.findGrepPreferences.findWhat = "(\\[|\\])";	// this steals from "[{TM}]" or "[{SM}]" which are handled below							app.findGrepPreferences.findWhat = "(\\[\\[|\\]\\])";	// only remove from actual doubles, like "[[" or "]]"							app.changeGrepPreferences.changeTo = "";							foundItems[textCounter].changeGrep();						}					}					//Next, search for any instances of this variable that weren't in conditional text.					//Need to do this because a given variable might appear in multiple places.					document.changeText();				}				else{					//The variable didn't exist in conditional text, so simply replace it.					app.findTextPreferences.findWhat = "{{" + variableName + "}}";					app.changeTextPreferences.changeTo = content;					document.changeText();				}				//				resetFindChangePreferences();				app.findChangeTextOptions.includeMasterPages = saved;			} else {				// path replacement for a link				processGraphicVariable(document, key.substr(1), graphicFolderBasePath + value);			}		}	} catch (e) {		logMessage("Exception in processOverviewData: " + e.message);	}}/////////////////////////////////  XML VARIABLE LISTS  /////////////////////////////////////////////////// very simple S1-like scheme, using a map file instead of a simple variable file// each line is a key and a value -- the indd file has the "{{" and "}}" around key placeholders// map file entries file lack "{{" and "}}" and the RHS is a partial xml search pathfunction processXMLVariableList(document, dataFilePath, mapFilePath) {	var bParamsOK = true;	try {		if (dataFilePath.length > 0 && mapFilePath.length > 0) {			if(File(dataFilePath).exists && File(mapFilePath).exists){				var dataXML = readXMLFile(dataFilePath);				var map = readTextFile(mapFilePath);			} else {				if (!File(dataFilePath).exists) {					logMessage("Data file not found; skipping this xmlvariable list", "Error");					bParamsOK = false;				} else {					logMessage("Map file not found; skipping this xml variable list", "Error");					bParamsOK = false;				}			}		} else {			if (dataFilePath.length == 0) {				logMessage("Data file path not provided; skipping this xml variable list", "Error");				bParamsOK = false;			} else if (mapFilePath.length == 0) {				logMessage("Map file path not provided; skipping this xml variable list", "Error");				bParamsOK = false;			}		}		if (bParamsOK) {			map = splitData(map);			// map should be an array			for (var i=0; i<map.length; i++) {				var thisLine = map[i];				if (thisLine.length < 2)					continue;				var key = thisLine[0];				if (key.length == 0)					continue;				var value = "";				var xmlFrag = thisLine[1];				if (xmlFrag != "") {					var searchStr = "dataXML.." + xmlFrag;					var searchResult = eval(searchStr);					if (searchResult.length() > 0)						value = searchResult[0].text().toString();				}				if (key.substr(0,1) != "@") {	// normal find/change					resetFindChangePreferences();					var saved = app.findChangeTextOptions.includeMasterPages;					app.findChangeTextOptions.includeMasterPages = true;					value = processSpecialCharacters(value);					//	//~ 				// original simple approach that does not support conditionals	//~ 				app.findTextPreferences.findWhat = "{{" + key + "}}";	//~ 				app.changeTextPreferences.changeTo = value;	//~ 				var results = document.findText();	//~ 				document.changeText();					var foundItems;					var variableName = key;					var content = value;					//From PrestoboxLayout.jsx					//Does the variable exist in a conditional variable?					app.findGrepPreferences.findWhat = "\\[\\[([^\\{]*)\\{\\{" + variableName + "\\}\\}([^\\]]*)\\]\\]";					foundItems = document.findGrep(true);					//If foundItems contains text objects, then the variable existed					//inside conditional markup.					if(foundItems.length > 0){						app.findTextPreferences.findWhat = "{{" + variableName + "}}";						app.changeTextPreferences.changeTo = content;						//If the variable is empty, simply remove it.						if(content == ""){							for(textCounter = 0; textCounter < foundItems.length; textCounter++){								foundItems[textCounter].remove();							}						}						else{							//The variable wasn't empty, so replace the variable and then							//remove the conditional text markers.							for(textCounter = 0; textCounter < foundItems.length; textCounter++){								//Change the variable in the found text. Note that we do it this way								//because using grep and the captured text ($1, $2) from the above								//findGrep results in misplaced formatting when the found text								//contains more than one format.								foundItems[textCounter].changeText();								//Remove conditional markers from the found text.								//app.findGrepPreferences.findWhat = "(\\[|\\])";	// this steals from "[{TM}]" or "[{SM}]" which are handled below								app.findGrepPreferences.findWhat = "(\\[\\[|\\]\\])";	// only remove from actual doubles, like "[[" or "]]"								app.changeGrepPreferences.changeTo = "";								foundItems[textCounter].changeGrep();							}						}						//Next, search for any instances of this variable that weren't in conditional text.						//Need to do this because a given variable might appear in multiple places.						document.changeText();					}					else{						//The variable didn't exist in conditional text, so simply replace it.						app.findTextPreferences.findWhat = "{{" + variableName + "}}";						app.changeTextPreferences.changeTo = content;						document.changeText();					}					//					resetFindChangePreferences();					app.findChangeTextOptions.includeMasterPages = saved;				} else {					// path replacement for a link					processGraphicVariable(document, key.substr(1), graphicFolderBasePath + value);				}			}		}	} catch (e) {		logMessage("Exception in processXMLVariableList: " + e.message);	}}/////////////////////////////////  TEXTFRAME VARIABLES  ////////////////////////////////////////////function processTextFrameJob(document, dataFilePath, searchStr){	processTextFrameVariable(document, dataFilePath, searchStr);}/////////////////////////////////  STORY VARIABLES  ////////////////////////////////////////////function processStoryJob(document, data, xml, graphicFolderBasePath, searchStr){	xml = processStory(document, data, xml, graphicFolderBasePath);	var snippetFile;	if (g_bTesting)		snippetFile = new File(document.filePath.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	else		snippetFile = new File(Folder.temp.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	// File.saveDialog ("Save snippet as");	writeXMLFile (xml, snippetFile);	// Place the snippet, then suck out its guts and inject this into the main story	var snippetFrame = document.pages.item(0).place(snippetFile)[0];	snippetFrame.geometricBounds = [6, -6, 8, 2];	// inches	moveTableSnippet(document, snippetFrame, searchStr);	if (!g_bTesting)		snippetFile.remove();}function getUniqueFilename(prefixStr) {	var today = new Date();	var filenameString = prefixStr;	filenameString = filenameString.concat("_",today.getFullYear(),("0"+(today.getMonth()+1)).slice(-2),("0"+today.getDate()).slice(-2),("0"+today.getHours()).slice(-2),("0"+today.getMinutes()).slice(-2),("0"+today.getSeconds()).slice(-2),("0"+today.getMilliseconds()).slice(-3));	return filenameString;}function processStory(document, data, xml, graphicFolderBasePath){	data = splitData(data);	// if there's data, replace the content of the story -- might also need to remove all PSR/CSR's after the first one	var dataRow, variableName, value, regExp, regExpString, fieldCounter, string;	for(var recordCounter = 0; recordCounter < data.length; recordCounter++){		dataRow = data[recordCounter];		if(dataRow == ""){			continue;		}		if(dataRow[0].match(/(\{|\})/g) == null){			variableName = "{{" + dataRow[0] + "}}";		}		else{			variableName = dataRow[0];		}		//...get the value.		value = dataRow[1];		if (variableName.substr(2,1) != "@") {			value = value.replace("$", "^^^");	// avoid dollar-sign confusion in replace() below			regExpString = variableName;			regExp = new RegExp(regExpString, "gi");			//Replace the variable in the Content nodes of the story.			var psrs = xml..ParagraphStyleRange;			for (var psrCounter=0; psrCounter<psrs.length(); psrCounter++) {				var thisPSR = psrs[psrCounter];				for (var csrCounter=0; csrCounter<thisPSR.CharacterStyleRange.length(); csrCounter++) {					var thisCSR = thisPSR.CharacterStyleRange[csrCounter];					for (var contentCounter=0; contentCounter<thisCSR.Content.length(); contentCounter++) {						if(thisCSR.Content[contentCounter].match(regExp) != null){							var string = thisCSR.Content[contentCounter].toString();							string = string.replace(regExp, value);							string = string.replace("^^^", "$");	// restore any dollar signs we lost							string = processSpecialCharacters(string);							thisCSR.Content[contentCounter] = string;						}					}				}			}		} else {			// the variable refers to a graphic			var variableNameSansAt = "{{" + variableName.substr(3);			var xmlRects = xml..Rectangle.(@Name==variableNameSansAt);			if (xmlRects.length() > 0) {				var newPath = graphicFolderBasePath + value;				var newFile = new File(newPath);				if (newFile.exists) {					for (var rI=0; rI<xmlRects.length(); rI++) {						var thisRect = xmlRects[rI];						var thisRectLink = thisRect..Link;						thisRectLink.@LinkResourceURI = "file:" + normalizePath(newPath);						thisRectLink.@LinkResourceModified = "true";					}				}			}		}	}//	var xmlStory = getStoryXML(xml);	return xml;	// xmlStory;}/////////////////////////////////  XML STORY VARIABLES  ////////////////////////////////////////////function processXMLStoryJobIncremental(document, data, elementName, map, xml, graphicFolderBasePath, searchStr){	// look for the search string in the document	resetFindChangePreferences();	var fromWhat = searchStr;	var xmlStr = xml.toXMLString();	// change snippet back to just a string	app.findTextPreferences.findWhat = fromWhat;	var results = document.findText();	if (results.length > 0) {		for (var i=0; i<results.length; i++) {			var thisFoundText = results[i];			// loop through the relevant records of the xml			var toEval = " return data." + elementName;			var toEvalFn = new Function(toEval);			var xmlDataList = toEvalFn();			logMessage("In processXMLStoryJobIncremental; data has " + xmlDataList.length() + " <" + elementName + "> elements");			var lastDataXML;			for (var j=0; j<xmlDataList.length(); j++) {				if (j % 100 == 0)					logMessage("Processing data record " + j);				var newRoot = new XML("<root/>");				var thisDataXML = xmlDataList[j];				newRoot.appendChild(thisDataXML.copy());				var snippetXML = new XML(xmlStr);				snippetXML = processXMLStoryIncremental(document, newRoot, elementName, map, snippetXML, lastDataXML);				lastDataXML = thisDataXML;				var snippetFile;				if (g_bTesting)					snippetFile = new File(document.filePath.fsName + "/" + getUniqueFilename("snippet_") + ".idms");				else					snippetFile = new File(Folder.temp.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	// File.saveDialog ("Save snippet as");				writeXMLFile (snippetXML, snippetFile);				// Place the snippet, then suck out its guts and inject this into the main story				var snippetFrame = document.pages.item(0).place(snippetFile)[0];				snippetFrame.geometricBounds = [6, -6, 8, 2];	// inches				appendTableSnippet(snippetFrame, thisFoundText);				snippetFile.remove();			}			thisFoundText.remove();		}	}	resetFindChangePreferences();//~ 			var itemCopy = item.duplicate([item.geometricBounds[1], item.geometricBounds[0]]);//~ 			itemCopy.parentStory.texts[0].move(LocationOptions.BEFORE, results[i]);	// ADDED '.parentStory' on behalf of xmlStory idea//~ //			itemTexts[0].move(LocationOptions.BEFORE, results[i]);//~ 			results[i].remove();//~ 			itemCopy.remove();//~ 		}//~ 	}//~ 	resetFindChangePreferences();//~ 	item.remove();//~ 	xml = processXMLStory(document, data, elementName, map, xml);//~ 	var snippetFile;//~ 	if (g_bTesting)//~ 		snippetFile = new File(document.filePath.fsName + "/" + getUniqueFilename("snippet_") + ".idms");//~ 	else//~ 		snippetFile = new File(Folder.temp.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	// File.saveDialog ("Save snippet as");//~ 	writeXMLFile (xml, snippetFile);//~ 	// Place the snippet, then suck out its guts and inject this into the main story//~ 	var snippetFrame = document.pages.item(0).place(snippetFile)[0];//~ 	snippetFrame.geometricBounds = [6, -6, 8, 2];	// inches//~ 	moveTableSnippet(document, snippetFrame, searchStr);//~ 	if (!g_bTesting)//~ 		snippetFile.remove();}function processXMLStoryJob(document, data, elementName, map, xml, graphicFolderBasePath, searchStr){	xml = processXMLStory(document, data, elementName, map, xml);	var snippetFile;	if (g_bTesting)		snippetFile = new File(document.filePath.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	else		snippetFile = new File(Folder.temp.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	// File.saveDialog ("Save snippet as");	writeXMLFile (xml, snippetFile);	// Place the snippet, then suck out its guts and inject this into the main story	var snippetFrame = document.pages.item(0).place(snippetFile)[0];	snippetFrame.geometricBounds = [6, -6, 8, 2];	// inches	moveTableSnippet(document, snippetFrame, searchStr);	if (!g_bTesting)		snippetFile.remove();}function sortXMLList(inXMLList, sortName) {	var outList = new XMLList();	var itemArray = [];	var keyStr = "";	for (var i=0; i<inXMLList.length(); i++) {		if (sortName != "") {			var toEval = "inXMLList[i]." + sortName;			var keyStr = eval(toEval);		}		itemArray.push({sortkey:keyStr, element:inXMLList[i]});	}	function sortfn(a,b) {		var aLC = a.sortkey.toLowerCase();		var bLC = b.sortkey.toLowerCase();		if (aLC < bLC)			return -1;		else if (aLC > bLC)			return 1;		else			return 0;	}	itemArray.sort(sortfn);	return itemArray;}//~ 	for (i=0; i<itemArray.length; i++) {//~ 		if (i==0)//~ 			outList = outList.insertChildAfter(null, itemArray[i].element);//~ 		else//~ 			outList = outList.insertChildAfter(outList[outList.length()-1], itemArray[i].element);//~ 	}//~ 	return outList;//~ }function processXMLStory(document, dataXML, elementName, map, snippetXML){	var mapInfo = getMapInfo(map);	var mainMap = mapInfo.map;	var toEval = "dataXML.." + elementName;	var unsortedList = eval(toEval);	var xmlDataList = sortXMLList(unsortedList, "SortProjectName");//	logMessage("In processXMLStory; dataXML has " + xmlDataList.length() + " <" + elementName + "> elements");	var snippetPSRXML = getParagraphStyleRangesXML(snippetXML..Story, true);  	// was snippetXML	for (var xmlI=0; xmlI<xmlDataList.length; xmlI++) {		if (xmlI % 100 == 0)			logMessage("On xmlDataList record " + xmlI);		var thisPSRcopy = snippetPSRXML.copy();		var thisElement = xmlDataList[xmlI].element;		// handle the 'onfirst' item if present		if (xmlI == 0 && mapInfo.onFirstObj.hasOwnProperty("snippetPath")) {			var thisItem = mapInfo.onFirstObj;			var useSnippetFilePath = thisItem.snippetPath;			var useSnippetXML = readXMLFile(useSnippetFilePath);			// get a copy of the story's PSR's and remove the originals			var useSnippetPSRXML = getParagraphStyleRangesXML(useSnippetXML..Story, true);			var useMap = thisItem.map;			processItemVariables(useMap, thisElement, useSnippetPSRXML);			// add the modified PSR's to the original table			for (var psrCounter=0; psrCounter<useSnippetPSRXML.ParagraphStyleRange.length(); psrCounter++)				//snippetXML..Story.appendChild(useSnippetPSRXML.ParagraphStyleRange[psrCounter]);				useSnippetXML..Story.appendChild(useSnippetPSRXML.ParagraphStyleRange[psrCounter]);			// Add the table to the original snippet			for (psrCounter=0; psrCounter<useSnippetXML..Story.ParagraphStyleRange.length(); psrCounter++)				snippetXML..Story.appendChild(useSnippetXML..Story.ParagraphStyleRange[psrCounter]);			// and the table-related styles			for (var sI=0; sI<useSnippetXML.RootParagraphStyleGroup.ParagraphStyle.length(); sI++) {				snippetXML[0].RootParagraphStyleGroup.appendChild(useSnippetXML.RootParagraphStyleGroup.ParagraphStyle[sI]);			}			for (sI=0; sI<useSnippetXML.RootCharacterStyleGroup.CharacterStyle.length(); sI++) {				snippetXML[0].RootCharacterStyleGroup.appendChild(useSnippetXML.RootCharacterStyleGroup.CharacterStyle[sI]);			}			if (snippetXML[0].RootCellStyleGroup.length() == 0)				snippetXML[0].appendChild(useSnippetXML.RootCellStyleGroup);			else {				for (sI=0; sI<useSnippetXML.RootCellStyleGroup.length(); sI++)					snippetXML[0].RootCellStyleGroup.appendChild(useSnippetXML.RootCellStyleGroup.CellStyle[sI]);			}			if (snippetXML[0].RootTableStyleGroup.length() == 0)				snippetXML[0].appendChild(useSnippetXML.RootTableStyleGroup);			else {				for (sI=0; sI<useSnippetXML.RootTableStyleGroup.length(); sI++)					snippetXML[0].RootTableStyleGroup.appendChild(useSnippetXML.RootTableStyleGroup.TableStyle[sI]);			}		}		// try to detect changes in child element content...		for (var watchThis in mapInfo.onChangeObj) {			var bChanged = false;			if (xmlI == 0) {				bChanged = true;				//$.writeln("Element zero; implicit change to '" + watchThis + "'");			} else {				var evalThisElement = "return thisElement." + watchThis + ".text().toString()";				var tmpFunc1 = new Function(evalThisElement);				var thisElementValue = tmpFunc1(evalThisElement);				var evalLastElement = "return xmlDataList[xmlI-1].element." + watchThis + ".text().toString()";				var tmpFunc2 = new Function(evalLastElement);				var lastElementValue = tmpFunc2(evalLastElement);				if (thisElementValue != lastElementValue) {					bChanged = true;					//$.writeln("Change of '" + watchThis + "' from '" + lastElementValue + "' to '" + thisElementValue + "'");				}			}			if (bChanged) {				// detected a change we need to act on				var thisItem = mapInfo.onChangeObj[watchThis];				var useSnippetFilePath = thisItem.snippetPath;				var useSnippetXML = readXMLFile(useSnippetFilePath);				// get a copy of the story's PSR's and remove the originals				var useSnippetPSRXML = getParagraphStyleRangesXML(useSnippetXML..Story, true);				var useMap = thisItem.map;				processItemVariables(useMap, thisElement, useSnippetPSRXML);				// add the modified PSR's to the original table				for (var psrCounter=0; psrCounter<useSnippetPSRXML.ParagraphStyleRange.length(); psrCounter++)					//snippetXML..Story.appendChild(useSnippetPSRXML.ParagraphStyleRange[psrCounter]);					useSnippetXML..Story.appendChild(useSnippetPSRXML.ParagraphStyleRange[psrCounter]);				// Add the table to the original snippet				for (psrCounter=0; psrCounter<useSnippetXML..Story.ParagraphStyleRange.length(); psrCounter++)					snippetXML..Story.appendChild(useSnippetXML..Story.ParagraphStyleRange[psrCounter]);				// and the table-related styles				for (var sI=0; sI<useSnippetXML.RootParagraphStyleGroup.ParagraphStyle.length(); sI++) {					snippetXML[0].RootParagraphStyleGroup.appendChild(useSnippetXML.RootParagraphStyleGroup.ParagraphStyle[sI]);				}				for (sI=0; sI<useSnippetXML.RootCharacterStyleGroup.CharacterStyle.length(); sI++) {					snippetXML[0].RootCharacterStyleGroup.appendChild(useSnippetXML.RootCharacterStyleGroup.CharacterStyle[sI]);				}				if (snippetXML[0].RootCellStyleGroup.length() == 0)					snippetXML[0].appendChild(useSnippetXML.RootCellStyleGroup);				else {					for (sI=0; sI<useSnippetXML.RootCellStyleGroup.length(); sI++)						snippetXML[0].RootCellStyleGroup.appendChild(useSnippetXML.RootCellStyleGroup.CellStyle[sI]);				}				if (snippetXML[0].RootTableStyleGroup.length() == 0)					snippetXML[0].appendChild(useSnippetXML.RootTableStyleGroup);				else {					for (sI=0; sI<useSnippetXML.RootTableStyleGroup.length(); sI++)						snippetXML[0].RootTableStyleGroup.appendChild(useSnippetXML.RootTableStyleGroup.TableStyle[sI]);				}			}		}		processItemVariables(mainMap, thisElement, thisPSRcopy);		for (psrCounter=0; psrCounter<thisPSRcopy.ParagraphStyleRange.length(); psrCounter++)			snippetXML..Story.appendChild(thisPSRcopy.ParagraphStyleRange[psrCounter]);	}//	var xmlStory = getStoryXML(xml);	return snippetXML;	// xmlStory;}function processXMLStoryIncremental(document, dataXML, elementName, map, snippetXML, lastDataXML){	var mapInfo = getMapInfo(map);	var mainMap = mapInfo.map;	var toEval = "dataXML." + elementName;	var xmlDataList = eval(toEval);	var snippetPSRXML = getParagraphStyleRangesXML(snippetXML..Story, true);  	// was snippetXML	for (var xmlI=0; xmlI<xmlDataList.length(); xmlI++) {		var thisPSRcopy = snippetPSRXML.copy();		var thisElement = xmlDataList[xmlI];		// try to detect changes in child element content...		for (var watchThis in mapInfo.onChangeObj) {			var bChanged = false;			if (typeof lastDataXML === "undefined") {				bChanged = true;				//$.writeln("Element zero; implicit change to '" + watchThis + "'");			} else {				var evalThisElement = "return thisElement." + watchThis + ".text().toString()";				var tmpFunc1 = new Function(evalThisElement);				var thisElementValue = tmpFunc1(evalThisElement);				var evalLastElement = "return lastDataXML." + watchThis + ".text().toString()";				var tmpFunc2 = new Function(evalLastElement);				var lastElementValue = tmpFunc2(evalLastElement);				if (thisElementValue != lastElementValue) {					bChanged = true;					//$.writeln("Change of '" + watchThis + "' from '" + lastElementValue + "' to '" + thisElementValue + "'");				}			}			if (bChanged) {				// detected a change we need to act on				var thisItem = mapInfo.onChangeObj[watchThis];				var useSnippetFilePath = thisItem.snippetPath;				var useSnippetXML = readXMLFile(useSnippetFilePath);				// get a copy of the story's PSR's and remove the originals				var useSnippetPSRXML = getParagraphStyleRangesXML(useSnippetXML..Story, true);				var useMap = thisItem.map;				processItemVariables(useMap, thisElement, useSnippetPSRXML);				// add the modified PSR's to the original table				for (var psrCounter=0; psrCounter<useSnippetPSRXML.ParagraphStyleRange.length(); psrCounter++)					//snippetXML..Story.appendChild(useSnippetPSRXML.ParagraphStyleRange[psrCounter]);					useSnippetXML..Story.appendChild(useSnippetPSRXML.ParagraphStyleRange[psrCounter]);				// Add the table to the original snippet				for (psrCounter=0; psrCounter<useSnippetXML..Story.ParagraphStyleRange.length(); psrCounter++)					snippetXML..Story.appendChild(useSnippetXML..Story.ParagraphStyleRange[psrCounter]);				// and the table-related styles				for (var sI=0; sI<useSnippetXML.RootParagraphStyleGroup.length(); sI++)					snippetXML[0].RootParagraphStyleGroup.appendChild(useSnippetXML.RootParagraphStyleGroup.ParagraphStyle[sI]);				for (sI=0; sI<useSnippetXML.RootCharacterStyleGroup.length(); sI++)					snippetXML[0].RootCharacterStyleGroup.appendChild(useSnippetXML.RootCharacterStyleGroup.CharacterStyle[sI]);				if (snippetXML[0].RootCellStyleGroup.length() == 0)					snippetXML[0].appendChild(useSnippetXML.RootCellStyleGroup);				else {					for (sI=0; sI<useSnippetXML.RootCellStyleGroup.length(); sI++)						snippetXML[0].RootCellStyleGroup.appendChild(useSnippetXML.RootCellStyleGroup.CellStyle[sI]);				}				if (snippetXML[0].RootTableStyleGroup.length() == 0)					snippetXML[0].appendChild(useSnippetXML.RootTableStyleGroup);				else {					for (sI=0; sI<useSnippetXML.RootTableStyleGroup.length(); sI++)						snippetXML[0].RootTableStyleGroup.appendChild(useSnippetXML.RootTableStyleGroup.TableStyle[sI]);				}			}		}		processItemVariables(mainMap, thisElement, thisPSRcopy);		for (psrCounter=0; psrCounter<thisPSRcopy.ParagraphStyleRange.length(); psrCounter++)			snippetXML..Story.appendChild(thisPSRcopy.ParagraphStyleRange[psrCounter]);	}//	var xmlStory = getStoryXML(xml);	return snippetXML;	// xmlStory;}function processItemVariables(thisMap, thisElement, thisPSRcopy) {	// needs:  thisMap, thisElement, thisPSRcopy,	var mapRow, variableName, value, childElementName, regExp, regExpString, string;	for (var mapI=0; mapI<thisMap.length; mapI++) {		mapRow = thisMap[mapI];		if (mapRow == "")			continue;		if(mapRow[0].match(/(\{|\})/g) == null){			variableName = "{{" + mapRow[0] + "}}";		}		else{			variableName = mapRow[0];		}		childElementName = mapRow[1];		var codeStr = "";		if (mapRow.length > 2)			codeStr = mapRow[2];		var paraStyleCodeStr = "";		if (mapRow.length > 3)			paraStyleCodeStr = mapRow[3];		var charStyleCodeStr = "";		if (mapRow.length > 4)			charStyleCodeStr = mapRow[4];		var toEval2 = "return thisElement." + childElementName + ".text().toString()";		var tmpFunc = new Function(toEval2);	// will this leak memory on repeated overwrite of tmpFunc?		value = tmpFunc();		if (true || value != "") {			value = value.replace("$", "^^^");	// avoid dollar-sign confusion in replace() below			regExpString = variableName;			regExp = new RegExp(regExpString, "gi");			//Replace the variable in the Content nodes of the story.			var psrs = thisPSRcopy..ParagraphStyleRange;			for (var psrCounter=0; psrCounter<psrs.length(); psrCounter++) {				var thisPSR = psrs[psrCounter];				var parastyle = thisPSR.@AppliedParagraphStyle.toString();				for (var csrCounter=0; csrCounter<thisPSR.CharacterStyleRange.length(); csrCounter++) {					var thisCSR = thisPSR.CharacterStyleRange[csrCounter];					for (var contentCounter=0; contentCounter<thisCSR.Content.length(); contentCounter++) {						if(thisCSR.Content[contentCounter].match(regExp) != null){							var charstyle = thisCSR.@AppliedCharacterStyle.toString();							var string = thisCSR.Content[contentCounter].toString();							if (codeStr != "") {								try {									var mapFunc = new Function(codeStr);									mapFunc(string);								} catch (e) {									logMessage("Exception running map's code string: " + e.message);									logMessage("code string: " + codeStr);								}							}							string = string.replace(regExp, value);							string = string.replace("^^^", "$");	// restore any dollar signs we lost							string = processSpecialCharacters(string);//~ 							if (codeStr != "") {//~ 								try {//~ 									var mapFunc = new Function(codeStr);//~ 									mapFunc(string);//~ 								} catch (e) {//~ 									logMessage("Exception running map's code string: " + e.message);//~ 									logMessage("code string: " + codeStr);//~ 								}//~ 							}							thisCSR.Content[contentCounter] = string;							if (paraStyleCodeStr != "") {								try {							//		logMessage("Found paraStyleCodeString: " + paraStyleCodeStr);							//		logMessage("Initial parastyle: " + parastyle);									var oldparastyle = parastyle;									var mapFunc2 = new Function(paraStyleCodeStr);									mapFunc2(string, parastyle);							//		logMessage("After function call, parastyle: " + parastyle);									if (parastyle != oldparastyle) {							//			logMessage("Changing thisPSR.@AppliedParagraphStyle to: " + parastyle);										thisPSR.@AppliedParagraphStyle = parastyle;									}								} catch (e) {									logMessage("Exception running map's parastyle code string: " + e.message);									logMessage("string: " + string);									logMessage("code string: " + paraStyleCodeStr);								}							}							if (charStyleCodeStr != "") {								try {							//		logMessage("Initial charstyle: " + charstyle);									var oldcharstyle = charstyle;									var mapFunc3 = new Function(charStyleCodeStr);									mapFunc3(string, charstyle);							//		logMessage("After function call, charstyle: " + charstyle);									if (charstyle != oldcharstyle) {										logMessage("value checked by char style code snippet: " + value);										logMessage("Changing thisCSR.@AppliedCharacterStyle to: " + charstyle);										thisCSR.@AppliedCharacterStyle = charstyle;									}								} catch (e) {									logMessage("Exception running map's charstyle code string: " + e.message);									logMessage("code string: " + charStyleCodeStr);								}							}						}					}				}			}		}	}}/////////////////////////////////  STATIC TABLES  ////////////////////////////////////////////function processStaticJob(document, data, xml, graphicFolderBasePath, searchStr){	xml = processStaticTable(document, data, xml, graphicFolderBasePath);	var snippetFile;	if (g_bTesting)		snippetFile = new File(document.filePath.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	else		snippetFile = new File(Folder.temp.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	// File.saveDialog ("Save snippet as");	writeXMLFile (xml, snippetFile);	// Place the snippet, then suck out its guts and inject this into the main story	var snippetFrame = document.pages.item(0).place(snippetFile)[0];	snippetFrame.geometricBounds = [6, -6, 12, 2];	// inches	moveTableSnippet(document, snippetFrame, searchStr);	if (!g_bTesting)		snippetFile.remove();}function processStaticTable(document, data, xml, graphicFolderBasePath){	var xmlCell;	data = splitData(data);	//data is now an array of arrays, where each array is a record and each record[n] is a field.	//The first record is the source of key names for each field, and must match the placeholders	//in the table.	var xmlTable = getTableXML(xml);	var xmlCells = xmlTable..Cell;	var variableName, cellCounter, xmlCell, value, regExp, regExpString, fieldCounter, dataRow, string, rowIndex;	//Iterate by data row, then by data column, then by XML cell.	for(var recordCounter = 0; recordCounter < data.length; recordCounter++){		dataRow = data[recordCounter];		if(dataRow == ""){			continue;		}		if(dataRow[0].match(/(\{|\})/g) == null){			variableName = "{{" + dataRow[0] + "}}";		}		else{			variableName = dataRow[0];		}		//...get the value.		value = dataRow[1];		if (variableName.substr(2,1) != "@") {			value = value.replace("$", "^^^");	// avoid dollar-sign confusion in replace() below			regExpString = variableName;			regExp = new RegExp(regExpString, "gi");			for(var xmlCellCounter = 0; xmlCellCounter < xmlCells.length(); xmlCellCounter++){				var xmlCell = xmlCells[xmlCellCounter];				//Replace the variable in the Content nodes of the Cell.				for (var psrCounter=0; psrCounter<xmlCell.ParagraphStyleRange.length(); psrCounter++) {					var thisPSR = xmlCell.ParagraphStyleRange[psrCounter];					for (var csrCounter=0; csrCounter<thisPSR.CharacterStyleRange.length(); csrCounter++) {						var thisCSR = thisPSR.CharacterStyleRange[csrCounter];						for (var contentCounter=0; contentCounter<thisCSR.Content.length(); contentCounter++) {							if(thisCSR.Content[contentCounter].match(regExp) != null){								var string = thisCSR.Content[contentCounter].toString();								string = string.replace(regExp, value);								string = string.replace("^^^", "$");	// restore any dollar signs we lost								string = processSpecialCharacters(string);								thisCSR.Content[contentCounter] = string;							}						}					}				}			}		} else {			// the variable refers to a graphic			var variableNameSansAt = "{{" + variableName.substr(3);			var xmlRects = xmlCells..Rectangle.(@Name==variableNameSansAt);			if (xmlRects.length() > 0) {				var newPath = graphicFolderBasePath + value;				var newFile = new File(newPath);				if (newFile.exists) {					for (var rI=0; rI<xmlRects.length(); rI++) {						var thisRect = xmlRects[rI];						var thisRectLink = thisRect..Link;						thisRectLink.@LinkResourceURI = "file:" + normalizePath(newPath);						thisRectLink.@LinkResourceModified = "true";					}				}			}		}	}	//Some of these have XMLElement, some don't.	if(xml.Story[0].XMLElement[0] != undefined){		delete xml.Story[0].XMLElement[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0];		xml.Story[0].XMLElement[0].ParagraphStyleRange[0].CharacterStyleRange[0].appendChild(xmlTable);	}	else{		delete xml.Story[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0];		xml.Story[0].ParagraphStyleRange[0].CharacterStyleRange[0].appendChild(xmlTable);	}	return xml;}//~ ///////////////////////////////// SINGLE ROW TABLES /////////////////////////////////////////////////~ function processSingleRowJob(document, data, xml, graphicFolderBasePath, searchStr){//~ 	xml = processSingleRowTable(document, data, xml, graphicFolderBasePath);//~ 	var snippetFile = new File(Folder.temp.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	// File.saveDialog ("Save snippet as");//~ 	writeXMLFile (xml, snippetFile);//~ 	// Place the snippet, then suck out its guts and inject this into the main story//~ 	var snippetFrame = document.pages.item(0).place(snippetFile)[0];//~ 	snippetFrame.geometricBounds = [6, -6, 12, 2];	// inches//~ 	moveTableSnippet(document, snippetFrame, searchStr);//~ 	snippetFile.remove();//~ }//~ //TO DO: Add error handling, weed out obsolete variables left over from development.//~ function processSingleRowTable(document, data, xml, graphicFolderBasePath){//~ 	var xmlCell;//~ 	data = splitData(data);//~ 	//data is now an array of arrays, where each array is a record and each record[n] is a field.//~ 	//The first record is the source of key names for each field, and must match the placeholders//~ 	//in the table.//~ 	var xmlTable = getTableXML(xml);//~ 	//Get the original number of body rows.//~ 	var bodyRowBase = Number(xmlTable.@BodyRowCount);//~ 	//Get the original total number of Rows.//~ 	var rowBase = xmlTable.Row.length() - 1;//~ 	var lastRowName = xmlTable.Row[xmlTable.Row.length() - 1].@Name.toString();//~ 	var columnCount = xmlTable.Column.length();//~ 	var rowCount = data.length;//~ 	var xmlCells = getSingleRowCellXML(xmlTable.copy(), lastRowName);//~ 	var cellNames = xmlCells.@Name;//~ 	//Deletes the last row of Cells, not the last row of Rows.//~ 	deleteLastRow(xmlTable, cellNames);//~ 	var variableName, value, cellCounter, xmlCell, dataRow;//~ 	////~ 	for(var rowCounter = 1; rowCounter < rowCount; rowCounter ++){//~ 		dataRow = data[rowCounter];//~ 		for(cellCounter = 0; cellCounter < dataRow.length; cellCounter++){//~ 			//First record in the data *must* match variable names.//~ 			variableName = data[0][cellCounter];//~ 			value = data[rowCounter][cellCounter];//~ 			if(variableName != ""){//~ 				variableName = "{{" + variableName + "}}";//~ 				writeToConsole(variableName);//~ 				if (variableName.substr(2,1) != "@") {//~ 					xmlCell = findCell(xmlCells, variableName);//~ 					if(xmlCell != null){//~ 						writeToConsole(dataRow[cellCounter]);//~ 						xmlCell.ParagraphStyleRange[0].CharacterStyleRange[0].Content = value;//~ 					}//~ 				} else {//~ 					// the variable refers to a graphic//~ 					var variableNameSansAt = "{{" + variableName.substr(3);//~ 					xmlCell = findGraphicCell(xmlCells, variableNameSansAt);//~ 					if (xmlCell != null) {//~ 						var xmlRect = xmlCell..Rectangle;//~ 						var newPath = graphicFolderBasePath + value;//~ 						var newFile = new File(newPath);//~ 						if (newFile.exists) {//~ 							var thisRectLink = xmlRect..Link;//~ 							thisRectLink.@LinkResourceURI = "file:" + normalizePath(newPath);//~ 							thisRectLink.@LinkResourceModified = "true";//~ 						}//~ 					}//~ 				}//~ 				if (xmlCell != null) {//~ 					//NOTE: get cell names right. InDesign populates the table by cell name.//~ 					xmlCell.@Name = cellCounter + ":" + String(Number(rowBase) + Number(rowCounter - 1));//~ 					xmlCell.@Self = "cell" + cellCounter + ":" + String(Number(rowBase) + Number(rowCounter - 1));//~ 					xmlTable.appendChild(xmlCell);//~ 				}//~ 			}//~ 		}//~ 	}//~ 	//NOTE: About Row elements//~ 	//last row will look something like this://~ 	//<Row Self="u16bi5f51Row4" Name="4" SingleRowHeight="13.5" MinimumHeight="13.5" AutoGrow="true"/>//~ 	//...increment last number in @Self and @Name.//~ 	xmlTable = addSingleRowRows(xmlTable, data.length);//~ 	//Update body row count.//~ 	xmlTable.@BodyRowCount = String(bodyRowBase + data.length - 2);//~ 	try {//~ 		delete xml.Story[0].XMLElement[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0];//~ 		xml.Story[0].XMLElement[0].ParagraphStyleRange[0].CharacterStyleRange[0].appendChild(xmlTable);//~ 	} catch (e) {//~ 		delete xml.Story[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0];//~ 		xml.Story[0].ParagraphStyleRange[0].CharacterStyleRange[0].appendChild(xmlTable);//~ 	}//~ 	return xml;//~ }//~ function addSingleRowRows(xmlTable, numberOfRows){//~ 	//We'll leave the existing last row in place.//~ 	numberOfRows = numberOfRows - 2;//~ 	if(numberOfRows > 0){//~ 		var lastRow = xmlTable.Row[xmlTable.Row.length() - 1];//~ 		var rowBase = lastRow.@Self.toString().match(/\d+$/)[0];//~ 		rowBase = Number(rowBase) + 1;//~ 		var rowPrefix = lastRow.@Self.toString().replace(/\d+$/, "");//~ 		var newRow, selfString;//~ 		for(var counter = 0; counter < numberOfRows; counter++){//~ 			newRow = lastRow.copy();//~ 			selfString = rowPrefix + String(Number(counter) + Number(rowBase));//~ 			//Add a new @Self--not really critical, can be about anything, but must be unique.//~ 			newRow.@Self = selfString;//~ 			//Add a new @Name that corresponds to the cell's location in the table.//~ 			newRow.@Name = String(Number(counter) + Number(rowBase));//~ 			//Insert new row after the last row in the table.//~ 			xmlTable.insertChildAfter(xmlTable.Row[xmlTable.Row.length() - 1], newRow);//~ 		}//~ 	}//~ 	return xmlTable;//~ }function addMultiRowRows(xmlTable, numberOfRows){	logMessage("In addMultiRowRows() with 'numberOfRows' = " + numberOfRows + "; table properties:");	logMessage("  HeaderRowCount: " + xmlTable.@HeaderRowCount.toString());	logMessage("  BodyRowCount: " + xmlTable.@BodyRowCount.toString());	logMessage("  SkipFirstHeader: " + xmlTable.@SkipFirstHeader.toString());//~ 	//We'll leave the existing last row in place.//~ 	numberOfRows = numberOfRows - 2;//~ 	logMessage("Adjusted 'numberOfRows' is " + numberOfRows);	if(numberOfRows > 0){		var lastRowIndex = xmlTable.Row.length() - 1;		var lastRow = xmlTable.Row[lastRowIndex];		var rowBase = Number(lastRow.@Name.toString()) + 1;		var rowPrefix = lastRow.@Self.toString();		var newRow, selfString;		for(var counter = 0; counter < numberOfRows; counter++){			newRow = lastRow.copy();			selfString = rowPrefix + String(Number(counter) + Number(rowBase));			//Add a new @Self--not really critical, can be about anything, but must be unique.			newRow.@Self = selfString;			//Add a new @Name that corresponds to the cell's location in the table.			var newRowNameStr = String(Number(counter) + Number(rowBase));			newRow.@Name = newRowNameStr;			logMessage("Adding Row with @Name: " + newRowNameStr);			//Insert new row after the last row in the table.			xmlTable.insertChildAfter(xmlTable.Row[xmlTable.Row.length() - 1], newRow);		}	}	return xmlTable;}//TO DO: Add error handling for regExp not found.function getSingleRowCellXML(xmlTable, lastRowName){	var xmlCell, xmlCellClone, cellName, rowCounter, columnCounter;	//Construct RegExp as a string so as to use the variable.	var regExpString = "\\d+:" + lastRowName;	var regExp = new RegExp(regExpString, "gi");	var foundCells = xmlTable.Cell.(@Name.match(regExp));	var xmlCells = new XML();	var xmlCells = foundCells.copy();	writeToConsole("Copied cell length: " + xmlCells.length());	return xmlCells;}//~ ////////////////////////////////////// MULTI-ROW TABLE HANDLING  //////////////////////////////////~ function processMultiRowJob(document, data, xml, graphicFolderBasePath, searchStr){//~ 	xml = processMultiRowTable(document, data, xml, graphicFolderBasePath);//~ 	var snippetFile = new File(Folder.temp.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	// File.saveDialog ("Save snippet as");//~ 	writeXMLFile (xml, snippetFile);//~ 	// Place the snippet, then suck out its guts and inject this into the main story//~ 	var snippetFrame = document.pages.item(0).place(snippetFile)[0];//~ 	snippetFrame.geometricBounds = [6, -6, 12, 2];	// inches//~ 	moveTableSnippet(document, snippetFrame, searchStr);//~ 	snippetFile.remove();//~ }//~ //TO DO: Add error handling, weed out obsolete variables left over from development.//~ function processMultiRowTable(document, data, xml, graphicFolderBasePath){//~ 	var xmlCell;//~ 	data = splitData(data);//~ 	//data is now an array of arrays, where each array is a record and each record[n] is a field.//~ 	//The first record is the source of key names for each field, and must match the placeholders//~ 	//in the table.//~ 	var xmlTable = getTableXML(xml);//~ 	//Get the original number of body rows.//~ 	var bodyRowBase = Number(xmlTable.@BodyRowCount);//~ 	//Get the original total number of Rows.//~ 	var headerRowCount = Number(xmlTable.@HeaderRowCount);//~ 	//TO DO: Instead of just getting the name of the last row, get the names of//~ 	//all body rows as an array.//~ 	// TODO:  Following is specific to clinical trials.idms and is too specific to 2 (skipped) header rows//~ 	var bodyRowNames = getBodyRowNames(xmlTable, headerRowCount + 1);//~ 	var columnCount = xmlTable.Column.length();//~ 	var rowCount = data.length;//~ 	//Use an array of row names, rather than a single row name.//~ 	var xmlCells = getMultiRowCellXML(xmlTable.copy(), bodyRowNames);//~ 	var cellNames = xmlCells.@Name;//~ 	//Deletes the last row of Cells, not the last row of Rows.//~ 	deleteLastRow(xmlTable, cellNames);//~ 	var cellIndex = xmlTable.Cell.length();	// 3; /* richg changed this *///~ 	var variableName, cellCounter, xmlCell, value, regExp, regExpString, fieldCounter, dataRow, string, rowIndex;//~ 	////~ 	//Iterate by data row, then by data column, then by XML cell.//~ 	for(var recordCounter = 1; recordCounter < data.length; recordCounter++){//~ 		dataRow = data[recordCounter];//~ 		if(dataRow == ""){//~ 			continue;//~ 		}//~ 		for(var xmlCellCounter = 0; xmlCellCounter < xmlCells.length(); xmlCellCounter++){//~ 			var xmlCell = xmlCells[xmlCellCounter].copy();//~ 			for(fieldCounter = 0; fieldCounter < dataRow.length; fieldCounter++){//~ 				//...get the key...//~ 				if(data[0][fieldCounter].match(/(\{|\})/g) == null){//~ 					variableName = "{{" + data[0][fieldCounter] + "}}";//~ 				}//~ 				else{//~ 					variableName = data[0][fieldCounter];//~ 				}//~ 				//...get the value.//~ 				value = dataRow[fieldCounter];//~ 				if (variableName.substr(2,1) != "@") {//~ 					regExpString = variableName;//~ 					regExp = new RegExp(regExpString, "gi");//~ 					//Replace the variable in the Content nodes of the Cell.//~ 					var xmlContentElements = xmlCell..Content;//~ 					for(var contentCounter = 0; contentCounter < xmlContentElements.length(); contentCounter++){//~ 						var xmlContentElement = xmlContentElements[contentCounter];//~ 						if(xmlContentElement.match(regExp) != null){//~ 							var string = xmlContentElement.toString();//~ 							string = string.replace(regExp, value);//~ 							var xmlParent = xmlContentElement.parent();//~ 							xmlParent.Content = string.replace(/####PARAGRAPH####/g,"\r\r");//~ 						}//~ 					}//~ 				} else {//~ 					// the variable name refers to a graphic//~ 					var variableNameSansAt = "{{" + variableName.substr(3);//~ 					var xmlRect = xmlCell..Rectangle;//~ 					var newPath = graphicFolderBasePath + value;//~ 					var newFile = new File(newPath);//~ 					if (newFile.exists) {//~ 						var thisRectLink = xmlRect..Link;//~ 						thisRectLink.@LinkResourceURI = "file:" + normalizePath(newPath);//~ 						thisRectLink.@LinkResourceModified = "true";//~ 					}//~ 				}//~ 			}//~ 			var nameString = xmlCell.@Name;//~ 			writeToConsole("original name: " + nameString);//~ 			var rowNumber = Number(nameString.match(/(\d+)$/g));//~ 			var columnNumber = Number(nameString.match(/^(\d+)/g));//~ 			//rowNumber = Number(rowNumber) + (xmlCells.length() * (recordCounter-1));//~ 			writeToConsole("rowNumber: " + rowNumber);//~ 			xmlTable.appendChild(xmlCell);//~ 			xmlTable.Cell[xmlTable.Cell.length() - 1].@Name = (columnNumber + ":" + cellIndex);//~ 			writeToConsole("Cell Name: " + xmlTable.Cell[xmlTable.Cell.length() - 1].@Name);//~ 			cellIndex ++;//~ 		}//~ 	}//~ 	//NOTE: About Row elements//~ 	//last row will look something like this://~ 	//<Row Self="u16bi5f51Row4" Name="4" SingleRowHeight="13.5" MinimumHeight="13.5" AutoGrow="true"/>//~ 	//...increment last number in @Self and @Name.//~ 	xmlTable = addMultiRowRows(xmlTable, (cellIndex - bodyRowBase));//~ 	//Update body row count.//~ 	xmlTable.@BodyRowCount = String(cellIndex - headerRowCount);//~ 	//Some of these have XMLElement, some don't.//~ 	if(xml.Story[0].XMLElement[0] != undefined){//~ 		delete xml.Story[0].XMLElement[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0];//~ 		xml.Story[0].XMLElement[0].ParagraphStyleRange[0].CharacterStyleRange[0].appendChild(xmlTable);//~ 	}//~ 	else{//~ 		delete xml.Story[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0];//~ 		xml.Story[0].ParagraphStyleRange[0].CharacterStyleRange[0].appendChild(xmlTable);//~ 	}//~ 	return xml;//~ }////////////////////////////////////// DYNAMIC TABLE HANDLING  ////////////////////////////////function processDynamicJob(document, data, xml, graphicFolderBasePath, searchStr){	xml = processDynamicTable(document, data, xml, graphicFolderBasePath);	var snippetFile;	if (g_bTesting)		snippetFile = new File(document.filePath.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	else		snippetFile = new File(Folder.temp.fsName + "/" + getUniqueFilename("snippet_") + ".idms");	// File.saveDialog ("Save snippet as");	writeXMLFile (xml, snippetFile);	// Place the snippet, then suck out its guts and inject this into the main story	var snippetFrame = document.pages.item(0).place(snippetFile)[0];	snippetFrame.geometricBounds = [6, -6, 12, 2];	// inches	moveTableSnippet(document, snippetFrame, searchStr);	if (!g_bTesting)		snippetFile.remove();}//TO DO: Add error handling, weed out obsolete variables left over from development.function processDynamicTable(document, data, xml, graphicFolderBasePath){	var xmlCell;	data = splitData(data);	//data is now an array of arrays, where each array is a record and each record[n] is a field.	//The first record is the source of key names for each field, and must match the placeholders	//in the table.	var xmlTable = getTableXML(xml);	//Get the original number of body rows.	var bodyRowBase = Number(xmlTable.@BodyRowCount);	//Get the original total number of Rows.	var headerRowCount = Number(xmlTable.@HeaderRowCount);	//TO DO: Instead of just getting the name of the last row, get the names of	//all body rows as an array.	var bSkipFirstHeader = xmlTable.@SkipFirstHeader.toXMLString() == "true";	var origSkipCount = headerRowCount + 1;	var betterSkipCount = bSkipFirstHeader ? ((headerRowCount*2)-1) : (headerRowCount-1);	var bodyRowNames = getBodyRowNames(xmlTable, betterSkipCount);	var columnCount = xmlTable.Column.length();	var rowCount = data.length;	//Use an array of row names, rather than a single row name.	var xmlCells = getMultiRowCellXML(xmlTable.copy(), bodyRowNames);	var cellNames = xmlCells.@Name;	//Deletes the last row of Cells, not the last row of Rows.	deleteLastRow(xmlTable, cellNames);	var cellIndex = xmlTable.Cell.length();	// 3; /* richg changed this */	var variableName, cellCounter, xmlCell, value, regExp, regExpString, fieldCounter, dataRow, string, rowIndex;	//	// rich added	var currentTableRow = -1;	var lastTableRow = -1;	var baseTableRow = -1;	var rowCellCountObj = {};	var rowsAdded = 0;	// end add	//Iterate by data row, then by data column, then by XML cell.	for(var recordCounter = 1; recordCounter < data.length; recordCounter++){		dataRow = data[recordCounter];		if(dataRow == ""){			continue;		}		currentTableRow++;	// assume that each data row at least starts a new table row		var firstTableRow = currentTableRow;		var currentTableCol = 0;	// Rich added		for(var xmlCellCounter = 0; xmlCellCounter < xmlCells.length(); xmlCellCounter++){			var xmlCell = xmlCells[xmlCellCounter].copy();			// Rich added			var thisCellName = xmlCell.@Name.toString();			var thisCellNameParts = thisCellName.split(":");			var thisCellColStr = thisCellNameParts[0];			var thisCellRowStr = thisCellNameParts[1];			var thisCellCol = parseInt(thisCellColStr);			var thisCellRow = parseInt(thisCellRowStr);			if (lastTableRow == -1) {				currentTableRow = parseInt(bodyRowNames[0]);				firstTableRow = currentTableRow;				lastTableRow = thisCellRow;				baseTableRow = thisCellRow;			}			if (thisCellRow != lastTableRow) {				// first time through or when bumped to another row				currentTableRow = firstTableRow + (thisCellRow - baseTableRow);				lastTableRow = currentTableRow;			}			currentTableCol = thisCellCol.toString();			// end add			for(fieldCounter = 0; fieldCounter < dataRow.length; fieldCounter++){				//...get the key...				if(data[0][fieldCounter].match(/(\{|\})/g) == null){					variableName = "{{" + data[0][fieldCounter] + "}}";				}				else{					variableName = data[0][fieldCounter];				}				//...get the value.				value = dataRow[fieldCounter];				if (variableName.substr(2,1) != "@") {					value = value.replace("$", "^^^");	//. avoid dollar-sign confusion in .replace() below					regExpString = variableName;					regExp = new RegExp(regExpString, "gi");					//Replace the variable in the Content nodes of the Cell.					for (var psrCounter=0; psrCounter<xmlCell.ParagraphStyleRange.length(); psrCounter++) {						var thisPSR = xmlCell.ParagraphStyleRange[psrCounter];						for (var csrCounter=0; csrCounter<thisPSR.CharacterStyleRange.length(); csrCounter++) {							var thisCSR = thisPSR.CharacterStyleRange[csrCounter];							for (var contentCounter=0; contentCounter<thisCSR.Content.length(); contentCounter++) {								if(thisCSR.Content[contentCounter].match(regExp) != null){									var string = thisCSR.Content[contentCounter].toString();									string = string.replace(regExp, value);									string = string.replace("^^^", "$");	// get back any dollar signs we lost									string = processSpecialCharacters(string);									thisCSR.Content[contentCounter] = string;								}							}						}					}				} else {					// the variable refers to a graphic					var variableNameSansAt = "{{" + variableName.substr(3);					var xmlRects = xmlCell..Rectangle.(@Name==variableNameSansAt);					if (xmlRects.length() > 0) {						if (value != "") {							var newPath = graphicFolderBasePath + value;							var newFile = new File(newPath);							if (newFile.exists) {								for (var rI=0; rI<xmlRects.length(); rI++) {									var thisRect = xmlRects[rI];									var thisRectLink = thisRect..Link;									thisRectLink.@LinkResourceURI = "file:" + normalizePath(newPath);									thisRectLink.@LinkResourceModified = "true";								}							}						} else {							for (rI=0; rI<xmlRects.length(); rI++ ) {								delete xmlRects[rI];							}						}					}				}			}			var nameString = xmlCell.@Name;			writeToConsole("original name: " + nameString);			var rowNumber = Number(nameString.match(/(\d+)$/g));			var columnNumber = Number(nameString.match(/^(\d+)/g));			var bSkipEmptyCells = true;			var bCellIsEmpty = (string == "");			var currentTableRowStr = currentTableRow.toString();			if (typeof rowCellCountObj[currentTableRowStr] === "undefined") {				rowCellCountObj[currentTableRowStr] = {bHasCells:false};				rowsAdded++;			}			if (!bSkipEmptyCells || !bCellIsEmpty) {				//rowNumber = Number(rowNumber) + (xmlCells.length() * (recordCounter-1));				writeToConsole("rowNumber: " + rowNumber);				xmlTable.appendChild(xmlCell);				xmlTable.Cell[xmlTable.Cell.length() - 1].@Name = (currentTableCol + ":" + currentTableRow);	// Rich changed from below	//			xmlTable.Cell[xmlTable.Cell.length() - 1].@Name = (columnNumber + ":" + cellIndex);				logMessage("Appended cell  with @Name: " + xmlTable.Cell[xmlTable.Cell.length() - 1].@Name);				rowCellCountObj[currentTableRowStr].bHasCells = true;			} else {				logMessage("Empty cell " + currentTableCol + ":" + currentTableRow + " skipped");			}			cellIndex ++;		}	}	//NOTE: About Row elements	//last row will look something like this:	//<Row Self="u16bi5f51Row4" Name="4" SingleRowHeight="13.5" MinimumHeight="13.5" AutoGrow="true"/>	//...increment last number in @Self and @Name.	logMessage("Number of rows occupied by appended Cells: " + rowsAdded);	logMessage("Value of currentTableRow: " + currentTableRow);	var lastRowIndex = xmlTable.Row.length() - 1;	var lastRowXML = xmlTable.Row[lastRowIndex];	var lastRowNum = Number(lastRowXML.@Name.toString());	var rowCount = lastRowNum + 1;	// since 0-based	var bFirstHeaderSkipped = (xmlTable.@SkipFirstHeader.toString() == "true");	var nonDataRowCount = headerRowCount;	if (bFirstHeaderSkipped)		nonDataRowCount++;	logMessage("Value of nonDataRowCount: " + nonDataRowCount);	var neededRowCount = currentTableRow - (rowCount-nonDataRowCount);	logMessage("Calculated number of Row elements needed: " + neededRowCount);	var numberOfRows =  (/*cellIndex*/(currentTableRow+1) - bodyRowBase);//~ 	for (var rowStr in rowCellCountObj) {//~ 		if (!rowCellCountObj[rowStr].bHasCells)//~ 			numberOfRows--;//~ 	}	xmlTable = addMultiRowRows(xmlTable, neededRowCount);	// was numberOfRows);	//Update body row count.	xmlTable.@BodyRowCount = String(/*cellIndex*/(currentTableRow+1) - headerRowCount);	//Some of these have XMLElement, some don't.	if(xml.Story[0].XMLElement[0] != undefined){		delete xml.Story[0].XMLElement[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0];		xml.Story[0].XMLElement[0].ParagraphStyleRange[0].CharacterStyleRange[0].appendChild(xmlTable);	}	else{		delete xml.Story[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0];		xml.Story[0].ParagraphStyleRange[0].CharacterStyleRange[0].appendChild(xmlTable);	}	adjustForRowSpans(xml);	fixEmbeddedReturns(xml);	return xml;}////////////////////////////////////////////////function getBodyRowNames(xmlTable, headerRowCount){	var bodyRowNames = [];	var xmlRows = xmlTable.Row;	for(var counter = 0; counter < xmlRows.length(); counter++){		if(Number(xmlRows[counter].@Name.toString()) > Number(headerRowCount)){			bodyRowNames.push(xmlRows[counter].@Name.toString());		}	}	return bodyRowNames;}//TO DO: Add error handling for regExp not found.function getMultiRowCellXML(xmlTable, bodyRowNames){	var xmlCell, xmlCellClone, cellName, rowCounter, columnCounter, bodyRowName;	//Construct regExp string using multiple OR cases.	var string = "(";	for(var counter = 0; counter < bodyRowNames.length; counter++){		string += bodyRowNames[counter];		if(!(counter == bodyRowNames.length - 1)){			string += "|";		}		else{			string += ")";		}	}	//Construct RegExp as a string so as to use the variable.	var regExpString = "\\d+:" + string;	writeToConsole(regExpString);	var regExp = new RegExp(regExpString, "gi");	var foundCells = xmlTable.Cell.(@Name.match(regExp));	var xmlCells = new XML();	var xmlCells = foundCells.copy();	writeToConsole("Copied cell length: " + xmlCells.length());	return xmlCells;}var bWritingToConsole = false;function writeToConsole(str) {	if (bWritingToConsole)		$.writeln(str);}function is_server_execution(){	return (app.name == "Adobe InDesign Server");}function normalizePath( path, bChopTrailingSlash ){	if (typeof bChopTrailingSlash === "undefined")		var bChopTrailingSlash = true;    path = path.replace(/\\/g, "/");    path = path.replace(/\/\//g, "/");    if( bChopTrailingSlash && path.substr(path.length-1, 1) == "/" ) {        path = path.substr(0,(path.length-1));    }    return( path );}/*//TO DO: Add error handling for Cell not found.function findCell(xmlCells, variableName){//~ 	var xmlCell = null;//~ 	for (var i=0; i<xmlCells.length()-1; i++) {//~ 		if (xmlCells[i].ParagraphStyleRange[0].CharacterStyleRange[0].Content[0].text().toString() == variableName) {//~ 			xmlCell = xmlCells[i].copy();//~ 			break;//~ 		}//~ 	}//~ 	return xmlCell;	for (var cI=0; cI<xmlCells.length(); cI++) {		try {			if (xmlCells[cI].ParagraphStyleRange[0].CharacterStyleRange[0].Content[0].text().toString() == variableName) {				var xmlCell = xmlCells[cI];				break;			}		} catch (e) {}	}	if(xmlCell != null){		return xmlCell[0].copy();	}	return null;}function findGraphicCell(xmlCells, variableName){	for (var cI=0; cI<xmlCells.length(); cI++) {		try {			if (xmlCells[cI]..Rectangle.@Name.toString() == variableName) {				var xmlCell = xmlCells[cI];				break;			}		} catch (e) {}	}	if(xmlCell != null){		return xmlCell[0].copy();	}	return null;}*/function splitData(data){	var fields;	var records = data.split("\n");	data = [];	for(var counter = 0; counter < records.length; counter++){		fields = records[counter].split("\t");		data.push(fields);	}	return data;}function getMapInfo(data){	var fields;	var records = data.split("\n");	info = {map:[], onChangeObj:{}, onFirstObj:{}};	var bInChange = false;	var currList = info.map;	for(var counter = 0; counter < records.length; counter++){		var thisLine = records[counter];		if (thisLine == ""|| thisLine.charAt(0) == ";")			continue;	// skip empty or comment line		else {			fields = records[counter].split("\t");			if (fields[0] == ":onchange" && fields.length == 3) {				// expect child element name, snippet path				var onChangeItem = {map:[], snippetPath:normalizePath(fields[2])};				currList = onChangeItem.map;				info.onChangeObj[fields[1]] = onChangeItem;				continue;			} else if (fields[0] == ":onfirst" && fields.length == 2) {				// expect a snippet path				var onFirstItem = {map:[], snippetPath:normalizePath(fields[1])};				currList = onFirstItem.map;				info.onFirstObj = onFirstItem;				continue;			}		}		currList.push(fields);	}	return info;}function getStoryXML(xml){//~ 	var xmlStory;//~ 	//Some of these have an odd XMLElement, some don't.//~ 	if(xml.Story[0].XMLElement[0] == undefined){//~ 		xmlTable = xml.Story[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0].copy();//~ 	} else{//~ 		xmlTable = xml.Story[0].XMLElement[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0].copy();//~ 	}	return xml.Story[0].copy();}function getTableXML(xml){	var xmlTable;	//Some of these have an odd XMLElement, some don't.	if(xml.Story[0].XMLElement[0] == undefined){		xmlTable = xml.Story[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0].copy();	} else{		xmlTable = xml.Story[0].XMLElement[0].ParagraphStyleRange[0].CharacterStyleRange[0].Table[0].copy();	}	return xmlTable.copy();}function getParagraphStyleRangesXML(xml, bDelete) {	var xmlList = new XML(<root/>);	var psrRefList = xml.ParagraphStyleRange;	for (var i=0; i<psrRefList.length(); i++) {		xmlList.appendChild(psrRefList[i].copy());	}	if (bDelete) {		for (i=psrRefList.length()-1; i>=0; i--) {			delete xml.ParagraphStyleRange[i];	// was ..ParagraphStyleRange		}	}	return xmlList;}function getHeaderXML(xmlTable){	return xmlHeader;}//Deletes the last row of *Cells*, not the last <Row>.//The last row of Cells contains the variable placeholders,//so we don't need it once we've copied them to a new//set of template elements.function deleteLastRow(xmlTable, cellNames){	writeToConsole("Cells before: " + xmlTable.Cell.length());	for(var counter = 0; counter < cellNames.length(); counter++){		xmlCell = xmlTable.Cell.(@Name == cellNames[counter]);		delete xmlCell[0];	}	writeToConsole("Cells after: " + xmlTable.Cell.length());}function writeXMLFile(xml, filePath){	var bDoLogging = true;	if (bDoLogging)		logMessage("In writeXMLFile; writing to file: " + filePath);	var xmlString = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\r";	xmlString += "<?aid style=\"50\" type=\"snippet\" readerVersion=\"6.0\" featureSet=\"257\" product=\"10.2(69)\" ?>\r";	xmlString += "<?aid SnippetType=\"PageItem\"?>\r";	var prettyPrinting = XML.prettyPrinting;	XML.prettyPrinting = false;	xmlString += xml.toXMLString();	XML.prettyPrinting = prettyPrinting;	writeTextFile(filePath, xmlString);}function writeTextFile(filePath, string){	var file = new File(filePath);	file.encoding = "UTF-8";	file.open ("w");	file.write(string);	file.close();}function readXMLFile(filePath){	var bDoLogging = true;	var xml = null;	if (bDoLogging)		logMessage("In readXMLFile; reading text from file: " + filePath);	var string = readTextFile(filePath);	if (bDoLogging)		logMessage(string.length + " characters read from file; creating xml object");	try{		xml = new XML(string);	}	catch(error){	}	if (bDoLogging)		logMessage("Got xml object, returning");	return xml;}function readTextFile(filePath){	var string = "";	if(File(filePath).exists == true){		var file = (File(filePath));		var savedEncoding = file.encoding;		file.encoding = "UTF-8";		file.open ("r");		string = file.read();		file.close();		if (string.length == 0) {			// try different encoding			file.encoding = savedEncoding;			file.open("r");			string = file.read();			file.close();		}	}	return string;}function removeSearchStringInstance(doc, searchStr, bRemoveParagraph) {	if (typeof bRemoveParagraph === "undefined")		var bRemoveParagraph = false;	resetFindChangePreferences();	var fromWhat = searchStr;	app.findTextPreferences.findWhat = fromWhat;	var results = doc.findText();	if (results.length > 0) {		for (var i=0; i<results.length; i++) {			try {				var paras = results[i].paragraphs;				results[i].remove();				if (bRemoveParagraph)	// assume single paragraph for searchStr location					paras[0].remove();			} catch (e) {}		}	}	resetFindChangePreferences();}function moveTableSnippet(doc, item, searchStr) {//	var itemTexts = item.texts;	resetFindChangePreferences();	var fromWhat = searchStr;	//~ var fromWhat = "{{clinical_table}}";	app.findTextPreferences.findWhat = fromWhat;	var results = doc.findText();	if (results.length > 0) {		for (var i=0; i<results.length; i++) {			var itemCopy = item.duplicate([item.geometricBounds[1], item.geometricBounds[0]]);			itemCopy.parentStory.texts[0].move(LocationOptions.BEFORE, results[i]);	// ADDED '.parentStory' on behalf of xmlStory idea//			itemTexts[0].move(LocationOptions.BEFORE, results[i]);			results[i].remove();			itemCopy.remove();		}	}	resetFindChangePreferences();	item.remove();}function appendTableSnippet(item, appendHere) {	var itemCopy = item.duplicate([item.geometricBounds[1], item.geometricBounds[0]]);	itemCopy.parentStory.texts[0].move(LocationOptions.BEFORE, appendHere);	// ADDED '.parentStory' on behalf of xmlStory idea//	results[i].remove();	itemCopy.remove();	item.remove();}function resetFindChangePreferences(){	app.findGrepPreferences = NothingEnum.NOTHING;	app.changeGrepPreferences = NothingEnum.NOTHING;	app.findTextPreferences = NothingEnum.NOTHING;	app.changeTextPreferences = NothingEnum.NOTHING;}function cleanupConditionalVariables(doc) {	logMessage("cleanupConditionalVariables() begin");	var docPageCount = doc.pages.length;	// Note: this removes all whitespace conditional content; else simply removes the brackets	// (doesn't work right for static non-whitespace content in conditional part of variable)	var bUseGrep = true;	if (bUseGrep) {		var findCondStr = "\\[\\[[^\\]\\]]*?\\]\\]";		resetFindChangePreferences();		app.findGrepPreferences.findWhat = findCondStr;		var results = doc.findGrep(true);		for (var i=0; i<results.length; i++) {			var thisResult = results[i];			var middle = thisResult.contents.substr(2,thisResult.contents.length-4);			var middleNonWhitespace = middle.search(/\w/g);			if (middleNonWhitespace == -1)				thisResult.remove();	// toss any lacking non-whitespace			else {				app.findTextPreferences.findWhat = "[[";				app.changeTextPreferences.changeTo = "";				thisResult.changeText();				app.findTextPreferences.findWhat = "]]";				thisResult.changeText();			}		}		resetFindChangePreferences();	} else {		// turns out this is way slower		for (var sI=0; sI<doc.stories.length; sI++) {			var textItem = doc.stories[sI];			for (var chI=textItem.characters.length-2; chI>=0; chI--) {				var thisPair = textItem.characters.itemByRange(chI,chI+1);				if (thisPair.contents == "]]") {					var closingPairI = chI;					chI -= 2;					for (; chI>=0; chI--) {						thisPair = textItem.characters.itemByRange(chI, chI+1);						if (thisPair.contents == "[[") {							var openingPairI = chI;							var thisConditionalRange = textItem.characters.itemByRange(chI, closingPairI+1);							var middle = textItem.characters.itemByRange(chI+2, closingPairI-1);							var middleContents = middle.contents.toString();							var middleNonWhitespace = middleContents.search(/\w/g);							if (middleNonWhitespace == -1)								thisConditionalRange.remove();	// toss any lacking non-whitespace							else {									var thisLength = thisConditionalRange.characters.length;									thisConditionalRange.characters.itemByRange(thisLength-2, thisLength-1).remove();									thisConditionalRange.characters.itemByRange(0,1).remove();							}							break;						}					}				}			}		}	}	if (true || doc.pages.length < docPageCount)		removeUselessPagesAtEnd(doc);	logMessage("cleanupConditionalVariables() end");}var oldRedraw;var oldInteractionLevel;function inhibitUI(){	if (!is_server_execution())	{		oldRedraw = app.scriptPreferences.enableRedraw;		oldInteractionLevel = app.scriptPreferences.userInteractionLevel;		app.scriptPreferences.enableRedraw = false;		app.scriptPreferences.userInteractionLevel = UserInteractionLevels.NEVER_INTERACT;	}}function restoreUI(){	if (!is_server_execution())	{		app.scriptPreferences.enableRedraw = oldRedraw;		app.scriptPreferences.userInteractionLevel = oldInteractionLevel;	}}function processGraphicVariable(document, variableName, graphicFilePath){	var graphicFile = new File(graphicFilePath);	if (graphicFile.exists) {		var bFoundOne = false;		for (var i=0; i<document.allPageItems.length; i++) {			var pageItem = document.allPageItems[i];			if(pageItem.isValid && pageItem.name == "{{" + variableName + "}}"){				bFoundOne = true;				try {					pageItem.place(File(graphicFilePath));					pageItem.fit(FitOptions.APPLY_FRAME_FITTING_OPTIONS);					pageItem.fit(FitOptions.PROPORTIONALLY);				} catch (e) {					var placeError = new Error("Can't place image: " + graphicFilePath);					throw placeError;				}			}		}		if (!bFoundOne) {			logMessage("Did not find pageitem with variable name: " + "{{" + variableName + "}}; skipping variable", "Warning");//~ 			var varError = new Error("Can't find item with variable name: " + "{{" + variableName + "}}");//~ 			throw varError;		}	} else {		var fnfError = new Error("Can't find image file for: " + graphicFilePath);		throw fnfError;	}}function removeTextFrame(document, variableName){	var bFoundOne = false;	for (var i=0; i<document.textFrames.length; i++) {		var textFrame = document.textFrames[i];		if(textFrame.isValid && textFrame.name == "{{" + variableName + "}}"){			bFoundOne = true;			try {				textFrame.remove();			} catch (e) {				var textError = new Error("Problem removing textframe named '" + textFrame.name + "'");				throw textError;			}		}	}}function processTextFrameVariable(document, dataFilePath, variableName){	var bFoundOne = false;	for (var i=0; i<document.textFrames.length; i++) {		var textFrame = document.textFrames[i];		if(textFrame.isValid && textFrame.name == variableName) {			bFoundOne = true;			try {				var dataFile = new File(dataFilePath);				textFrame.place(dataFile);				textFrame.parentStory.recompose();			} catch (e) {				var textError = new Error("Problem assigning contents to textframe named '" + textFrame.name + "': " + e.message);				throw textError;			}		}	}	if (!bFoundOne) {		var varError = new Error("Can't find item with variable name: " + "{{" + variableName + "}}");		throw varError;	}}function addLeadingZeroesToString(str, digitsNeeded) {	while (str.length < digitsNeeded)		str = "0" + str;	return str;}function processSpecialCharacters(str) {	str = str.replace(/####PARAGRAPH####/g,"\r\r");	// handle paragraphs	str = str.replace(/####SOFTRETURN####/g,"\n");	// handle soft returns	str = str.replace(/&#039;/g, "'");	str = str.replace(/&quot;/g, "\"");	return str;}function repairUsingIDML(currentDoc) {	var thisFile = currentDoc.fullName;	var currentFileName = thisFile.displayName;	var nameSansExt = currentFileName.substr(0,currentFileName.lastIndexOf("."));	var idmlFile = new File(thisFile.parent.fsName + "/" + currentFileName + ".idml");	currentDoc.exportFile(ExportFormat.INDESIGN_MARKUP, idmlFile);	currentDoc.close(SaveOptions.YES);	app.open(idmlFile);	currentDoc = app.activeDocument;	var newFilePath = thisFile.parent.fsName + "/" + nameSansExt + ".indd";	var newFile = new File(newFilePath);	currentDoc.save(newFile);	if (!is_server_execution())		app.waitForAllTasks();	// currentDoc.close();	idmlFile.remove();}function removeUselessPagesAtEnd (document) {	document = app.documents[0].getElements()[0];		//refresh the reference	for (var i=document.pages.length-1; i>=0; i--) {		var pageItems = document.pages[i].pageItems;//~ 		var bFoundContent = pageItems.length > 0;		var bFoundContent = false;		for (var j=pageItems.length-1; !bFoundContent && j>=0; j--) {			var thisItem = pageItems[j].getElements()[0];			var typeNameStr = thisItem.constructor.name;			switch (typeNameStr) {				case "TextFrame"://~ 					var whichPageForIP = thisItem.parentStory.insertionPoints.item(-1).parentTextFrames[0].parentPage;//~ 					if (whichPageForIP.id == document.pages[i].id)//~ 						$.bp();					if (thisItem.contents != "")						bFoundContent = true;					else {						var ourPageDocumentOffset = document.pages[i].documentOffset;						var story = thisItem.parentStory;						var lastInsertionPoint = story.insertionPoints.item(-1);						var lastTextFrame = lastInsertionPoint.parentTextFrames[0];						var lastPage = lastTextFrame.parentPage;						var lastPageDocumentOffset = lastPage.documentOffset;						if (ourPageDocumentOffset <= lastPageDocumentOffset)							bFoundContent = true;//~ 						// check for frames occupied by table content//~ 						var itemCopy = thisItem.duplicate();//~ 						if (itemCopy.contents.length != "")//~ 							bFoundContent = true;//~ 						itemCopy.remove();					}					if (!bFoundContent)						thisItem.remove();					break;				default:					bFoundContent = true;	// wimp out					break;			}		}		if (!bFoundContent)			document.pages[i].remove();	}}function loadParametersFromXML(parametersXMLFilePath) {	try {		logMessage("parametersXMLFilePath: " + parametersXMLFilePath);		var parametersXML = readXMLFile(parametersXMLFilePath);		logMessage("parametersXML: " + parametersXML.toXMLString());		var graphicFolderBasePath = parametersXML..graphicFolderBasePath.@filePath.toString();		var inDesignFilePath = parametersXML..inDesignFilePath.@filePath.toString();		var outputFolderPath = parametersXML..outputFolderPath.@filePath.toString();		var outputBasename = parametersXML..outputBasename.@name.toString();		var overviewData = [];		var variableListsXML = parametersXML..VariableList;		for (var i=0; i<variableListsXML.length(); i++)			overviewData.push(variableListsXML[i].@filePath.toString());		var xmlVariableLists = [];		var xmlVariableListsXML = parametersXML..xmlVariableList;		for (var i=0; i<xmlVariableListsXML.length(); i++)			xmlVariableLists.push([xmlVariableListsXML[i].@xmlFilePath.toString(), xmlVariableListsXML[i].@mapFilePath.toString()]);		var textframeData = [];		var textFramesXML = parametersXML..TextFrame;		for (i=0; i<textFramesXML.length(); i++)			textframeData.push([textFramesXML[i].@textFilePath.toString(), textFramesXML[i].@searchString.toString()]);		var storyData = [];		var storyXML = parametersXML..Story;		for (i=0; i<storyXML.length(); i++)			storyData.push([storyXML[i].@textFilePath.toString(), storyXML[i].@snippetFilePath.toString(), storyXML[i].@searchString.toString()]);		var staticData = [];		var staticTableXML = parametersXML..StaticTable;		for (i=0; i<staticTableXML.length(); i++)			staticData.push([staticTableXML[i].@textFilePath.toString(), staticTableXML[i].@snippetFilePath.toString(), staticTableXML[i].@searchString.toString()]);		var dynamicData = [];		var dynamicTableXML = parametersXML..DynamicTable;		for (i=0; i<dynamicTableXML.length(); i++)			dynamicData.push([dynamicTableXML[i].@textFilePath.toString(), dynamicTableXML[i].@snippetFilePath.toString(), dynamicTableXML[i].@searchString.toString()]);		var xmlStoryData = [];		var xmlStoryXML = parametersXML..XMLStory;		for (i=0; i<xmlStoryXML.length(); i++)			xmlStoryData.push([xmlStoryXML[i].@xmlFilePath.toString(), xmlStoryXML[i].@elementName.toString(), xmlStoryXML[i].@mapFilePath.toString(), xmlStoryXML[i].@snippetFilePath.toString(), xmlStoryXML[i].@searchString.toString()]);		var conditionsData = [];		var conditionsXML = parametersXML..Condition;		for (i=0; i<conditionsXML.length(); i++)			conditionsData.push([conditionsXML[i].@name.toString(), conditionsXML[i].@visible.toString()]);		var retObj = {graphicFolderBasePath:graphicFolderBasePath, inDesignFilePath:inDesignFilePath, outputFolderPath:outputFolderPath, outputBasename:outputBasename,			overviewData:overviewData, textframeData:textframeData, storyData:storyData, staticData:staticData, dynamicData:dynamicData, xmlStoryData:xmlStoryData, xmlVariableLists:xmlVariableLists, conditionsData:conditionsData};	} catch (e) {		logMessage("Exception in loadParametersFromXML: " + e.message);	}	return retObj;}function fixClippingPaths(document) {	for (var i=0; i<document.allGraphics.length; i++) {		var graphic = document.allGraphics[i];		if (graphic.clippingPath.isValid && graphic.clippingPath.photoshopPathNames.length > 0) {			try {				graphic.clippingPath.clippingType = ClippingPathType.PHOTOSHOP_PATH;				logMessage("fixClippingPaths() applied Photoshop clipping path to graphic '" + graphic.itemLink.name + "'");			} catch (e) {				try {					graphic.clippingPath.appliedPathName = graphic.clippingPath.photoshopPathNames[0];					logMessage("fixClippingPaths() applied Photoshop clipping path to graphic '" + graphic.itemLink.name + "'");				} catch (e) {					logMessage("Could not fix clipping path for graphic '" + graphic.itemLink.name + "'");				}			}		}	}}function adjustForRowSpans(snippetXML) {	var tableXML = snippetXML..Table;	if (tableXML.length() == 1) {		var tableRowCount = parseInt(tableXML.@BodyRowCount.toString());		// Keep in mind tableRowCount is really bodyRowCount!		var adjustedRowCount = tableRowCount;		// look through Cell elements and take roll of rows represented		var rowCellCountObj = {};		var cellsXML = tableXML..Cell;		var trueRowCount = -1;		var lastSeenRowNumber = -1;		var rowCells = [];		for (var i=0; i<cellsXML.length(); i++) {			var thisCell = cellsXML[i];			var cellNameStr = thisCell.@Name.toString();			var nameParts = cellNameStr.split(":");			var cellRowStr = nameParts[1];			var cellRow = parseInt(cellRowStr);			if (typeof rowCellCountObj[cellRowStr] === "undefined") {				// we're on a new row				logMessage("First cell of row " + cellRowStr + " has @RowSpan of " + thisCell.@RowSpan.toString());				trueRowCount++;				if (lastSeenRowNumber != -1 && (cellRow - lastSeenRowNumber > 1)) {					// we skipped one or more rows					var numSkipped = (cellRow - lastSeenRowNumber) - 1;					adjustedRowCount -= numSkipped;					logMessage(numSkipped + " rows skipped prior to row " + cellRowStr + "; true row " + trueRowCount);					fixRowSpans(rowCells, trueRowCount, numSkipped);	//				$.bp();				}				rowCells = [];				rowCellCountObj[cellRowStr] = {bHasCells:true, trueRowCount:trueRowCount};				lastSeenRowNumber = cellRow;			}			rowCells.push(thisCell);			var fixedName = nameParts[0] + ":" + trueRowCount.toString();			thisCell.@Name = fixedName;		}		if (lastSeenRowNumber != -1 && (tableRowCount - lastSeenRowNumber > 1)) {			// we skipped one or more rows			var numSkipped = (tableRowCount - lastSeenRowNumber) ;			adjustedRowCount -= numSkipped;			logMessage(numSkipped + " rows skipped after row " + lastSeenRowNumber + "; true row " + trueRowCount);			fixRowSpans(rowCells, trueRowCount, numSkipped);		}		tableXML.@BodyRowCount = adjustedRowCount.toString();		// probably too simplistic:		var adjustedTotalRows = adjustedRowCount + parseInt(tableXML.@HeaderRowCount.toString());		for (i=tableXML.Row.length()-1; i>=adjustedTotalRows; i--)			delete tableXML.Row[i];	}}function fixRowSpans(lastRowCellsArray, rowNum, skippedCount) {	logMessage("Looking for cells with rowspan greater than 1 in last row (" + rowNum.toString() + ")");	for (var i=0; i<lastRowCellsArray.length; i++) {		var thisCell = lastRowCellsArray[i];		var rowSpan = parseInt(thisCell.@RowSpan.toString());		if (rowSpan > 1)			thisCell.@RowSpan = (rowSpan - skippedCount).toString();	}}function fixEmbeddedReturns(snippetXML) {	var cellXML = snippetXML..Cell;	var psrs = cellXML..ParagraphStyleRange;	for (var psrCounter=0; psrCounter<psrs.length(); psrCounter++) {		var thisPSR = psrs[psrCounter];		for (var csrCounter=0; csrCounter<thisPSR.CharacterStyleRange.length(); csrCounter++) {			var thisCSR = thisPSR.CharacterStyleRange[csrCounter];			for (var contentCounter=0; contentCounter<thisCSR.Content.length(); contentCounter++) {				var csrContent = thisCSR.Content[contentCounter].toString();				if(csrContent.indexOf("\r") != -1){					var string = thisCSR.Content[contentCounter].toString();					logMessage("Found RETURN in here: " + string);//~ 					string = string.replace(regExp, value);//~ 					string = string.replace("^^^", "$");	// restore any dollar signs we lost//~ 					string = processSpecialCharacters(string);//~ 					thisCSR.Content[contentCounter] = string;				}			}		}	}}//////////////////////////////////////////////////// PARAMETER FUNCTIONS //////////////////////////////////////////////////////function getParametersFromScriptArgs(graphicFolderBasePath, outputFolderPath, outputBasename, inDesignFilePath, overviewData, textframeData, storyData, staticData, dynamicData, xmlStoryData, xmlVariableData, conditionsData) {	var bGotParameters = false;	var parametersXMLArg = app.scriptArgs.isDefined("PARAMETERS-FILE-PATH") ? app.scriptArgs.getValue("PARAMETERS-FILE-PATH") : null;	if (parametersXMLArg != null) {		try {			var parametersXMLFilePath = parametersXMLArg;			// Dig the parameters out of the xml			var parmsObj = loadParametersFromXML(parametersXMLFilePath);			var graphicFolderBasePath = parmsObj.graphicFolderBasePath;			var inDesignFilePath =  parmsObj.inDesignFilePath;			var outputFolderPath = parmsObj.outputFolderPath;			var outputBasename =  parmsObj.outputBasename;			var overviewData =  parmsObj.overviewData;			var textframeData =  parmsObj.textframeData;			var storyData =  parmsObj.storyData;			var staticData =  parmsObj.staticData;			var dynamicData =  parmsObj.dynamicData;			var xmlStoryData =  parmsObj.xmlStoryData;			var xmlVariableData = parmsObj.xmlVariableLists;			var conditionsData = parmsObj.conditionsData;			bGotParameters = true;		} catch (e) {			consoleout("Exception getting parameters: " + e.message);		}	} else {		var inDesignFilePathArg = app.scriptArgs.isDefined("INDESIGN-FILE-PATH") ? app.scriptArgs.getValue("INDESIGN-FILE-PATH") : null;		var outputFolderPathArg = app.scriptArgs.isDefined("OUTPUT-FOLDER-PATH") ? app.scriptArgs.getValue("OUTPUT-FOLDER-PATH") : null;		var outputBasenameArg = app.scriptArgs.isDefined("OUTPUT-BASENAME") ? app.scriptArgs.getValue("OUTPUT-BASENAME") : null;		var graphicFolderBasePathArg = app.scriptArgs.isDefined("GRAPHIC-FOLDER-BASEPATH") ? app.scriptArgs.getValue("GRAPHIC-FOLDER-BASEPATH") : null;		var overviewDataArg = app.scriptArgs.isDefined("OVERVIEWDATA") ? app.scriptArgs.getValue("OVERVIEWDATA") : null;		var xmlVariableDataArg = app.scriptArgs.isDefined("XMLVARIABLEDATA") ? app.scriptArgs.getValue("XMLVARIABLEDATA") : null;		var textframeDataArg = app.scriptArgs.isDefined("TEXTFRAMEDATA") ? app.scriptArgs.getValue("TEXTFRAMEDATA") : null;		var storyDataArg = app.scriptArgs.isDefined("STORYDATA") ? app.scriptArgs.getValue("STORYDATA") : null;		var staticDataArg = app.scriptArgs.isDefined("STATICTABLEDATA") ? app.scriptArgs.getValue("STATICTABLEDATA") : null;		var dynamicDataArg = app.scriptArgs.isDefined("DYNAMICTABLEDATA") ? app.scriptArgs.getValue("DYNAMICTABLEDATA") : null;		var xmlStoryDataArg = app.scriptArgs.isDefined("XMLSTORYDATA") ? app.scriptArgs.getValue("XMLSTORYDATA") : null;		var conditionsDataArg = app.scriptArgs.isDefined("CONDITIONSDATA") ? app.scriptArgs.getValue("CONDITIONSDATA") : null;		//		if (inDesignFilePathArg != null && outputFolderPathArg != null && outputBasenameArg != null && graphicFolderBasePathArg != null ) {			bGotParameters = true;			theFilePath = theScriptFolder.parent.parent.fsName + "/Utilities/json2.jsx";			theFilePath = theFilePath.replace(/\\/g, "/");			theFile = new File(theFilePath);			if (!theFile.exists) {				theFilePath = theFilePath + "bin";				theFile = new File(theFilePath);			}			$.evalFile(theFile);			var inDesignFilePath = inDesignFilePathArg;	// location of indesign template to start from			var overviewDataJSON = overviewDataArg;	// locations of file holding key/value pairs for variables not handled by a snippet			var overviewData = JSON.parse(overviewDataJSON);			var xmlVariableDataJSON = xmlVariableDataArg;	// locations of file holding key/value pairs for variables not handled by a snippet			var xmlVariableData = JSON.parse(xmlVariableDataJSON);			var textframeDataJSON = textframeDataArg;	// array in JSON format			var textframeData = JSON.parse(textframeDataJSON);	// array of arrays, each inner array [datafile, variableinbraces] to bootstrap named textframes with text content			var storyDataJSON = storyDataArg;	// array in JSON format			var storyData = JSON.parse(storyDataJSON);	// array of arrays, each inner array [datafile, snippetfile, variableinbraces] to insert story snippet w/ optional data file for variable resolution			var xmlStoryDataJSON = xmlStoryDataArg;	// array in JSON format			var xmlStoryData = JSON.parse(xmlStoryDataJSON);	// array of arrays, each inner array [xmldatafile, elementname, mapfile, snippetfile, variableinbraces] to insert  story snippet w/ xml data file for variable resolution			var staticDataJSON = staticDataArg;	// array in JSON format			var staticData = JSON.parse(staticDataJSON);	// array of arrays, each inner array [datafile, snippetfile, variableinbraces] to insert a static table w/ optional data file for variable resolution			var dynamicDataJSON = dynamicDataArg;	// array in JSON format			var dynamicData = JSON.parse(dynamicDataJSON);	// array of arrays, each inner array [datafile, snippetfile, variableinbraces] to insert a dynamic table			var conditionsDataJSON = conditionsDataArg;	// array in JSON format			var conditionsData = JSON.parse(conditionsDataJSON);	// array of arrays, each inner array [conditionname, bVisible] to set conditions (assumed to already exist) in the template			var outputFolderPath = ensureEndsWithSeparator(outputFolderPathArg);	// folder path for output files			var outputBasename = outputBasenameArg;	// optional basename to use for output files (if not provided, decided in makeOutputPath() below			var graphicFolderBasePath = graphicFolderBasePathArg;	// basepath for graphic paths in "@variablename" uses in overviewData file		}	}	return bGotParameters;}